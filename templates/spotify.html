{% extends "base.html" %}

{% block title %}My Spotify - My Flask Website{% endblock %}

{% block content %}
    <style>
        /* Custom slider styling */
        .attribute-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #20b2aa 0%, #20b2aa 25%, #ffd700 50%, #ff6347 75%, #ff6347 100%);
            outline: none;
            width: 100px;
        }
        
        .attribute-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #333;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .attribute-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #333;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border: none;
        }
        
        /* Smaller sliders for playlist view */
        .attribute-slider.small {
            width: 80px;
            height: 5px;
        }
        
        .attribute-slider.small::-webkit-slider-thumb {
            width: 14px;
            height: 14px;
        }
        
        .attribute-slider.small::-moz-range-thumb {
            width: 14px;
            height: 14px;
        }
        
        /* Slider row styling */
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        /* Side-by-side slider container */
        .sliders-container {
            display: flex;
            gap: 30px;
            justify-content: space-between;
        }
        
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-label {
            font-weight: bold;
            font-size: 12px;
            color: #666;
            min-width: 45px;
        }
        
        .slider-value {
            font-size: 10px;
            color: #888;
            font-weight: normal;
            min-width: 60px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


    </style>

    {% if authenticated %}
        <!-- Two-column layout container -->
        <div style="display: flex; gap: 20px; margin: 20px 0;">
            
            <!-- Left column: Songs display area OR Liked Songs tagging (2/3 width) -->
            <div style="flex: 3; background-color: white; padding: 20px; border-radius: 10px;">
                
                <!-- Tab Interface -->
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; border-bottom: 2px solid #e9ecef;">
                        <button id="tag-songs-tab" 
                                onclick="switchTab('tag-songs')"
                                style="flex: 1; padding: 12px; border: none; background: none; cursor: pointer; font-size: 14px; font-weight: 500; color: #1db954; border-bottom: 2px solid #1db954;">
                            Tag Songs
                        </button>
                        <button id="create-playlists-tab" 
                                onclick="switchTab('create-playlists')"
                                style="flex: 1; padding: 12px; border: none; background: none; cursor: pointer; font-size: 14px; font-weight: 500; color: #666; border-bottom: 2px solid transparent;">
                            Create Playlists
                        </button>
                    </div>
                </div>
                
                <!-- Tab Content Container -->
                <div id="tab-content">
                    
                    <!-- Tag Songs Content (default active) -->
                    <div id="tag-songs-content" style="display: block;">
                        {% if liked_songs_mode %}
                            <!-- Liked Songs Tagging Mode -->
                            <div style="text-align: center; margin-bottom: 5px;">
                                <!-- Progress, Favourite, and Toggle Row -->
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; max-width: 90%; margin-left: auto; margin-right: auto;">
                                    <div style="font-size: 12px; color: #666;">
                                        <span id="song-progress">Song #{{ offset + 1 }}</span>
                                    </div>
                                    
                                    <!-- Favourite Button/Tag -->
                                    <div style="text-align: center;">
                                        <button id="favourite-btn-{{ current_song.db_id }}" onclick="toggleFavouriteTag({{ current_song.db_id }})" 
                                                style="background-color: #ffffff; color: #333; border: 1px solid #ddd; padding: 6px 12px; border-radius: 15px; font-size: 11px; cursor: pointer; font-weight: 600; transition: all 0.2s;">
                                            ⭐ Favourite
                                        </button>
                                    </div>
                                    
                                    <!-- Untagged Toggle -->
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <div style="font-size: 10px; color: #666;">Only un-tagged</div>
                                        <label style="position: relative; display: inline-block; width: 32px; height: 18px;">
                                            <input type="checkbox" id="untagged-toggle" {% if untagged_only %}checked{% endif %} 
                                                onchange="toggleUntaggedOnly()" style="opacity: 0; width: 0; height: 0;">
                                            <span class="toggle-slider" style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: {% if untagged_only %}#1db954{% else %}#ccc{% endif %}; transition: .4s; border-radius: 18px;"></span>
                                            <span class="toggle-circle" style="position: absolute; content: ''; height: 14px; width: 14px; left: {% if untagged_only %}16px{% else %}2px{% endif %}; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%;"></span>
                                        </label>
                                    </div>
                                </div>
                            </div>

                            {% if no_more_songs %}
                                <!-- No more songs message -->
                                <div style="text-align: center; padding: 60px;">
                                    <h2>All done!</h2>
                                    {% if untagged_only %}
                                        <p>You've tagged all your untagged liked songs!</p>
                                        <div style="margin-top: 20px;">
                                            <a href="/tag-liked-songs?offset=0&untagged_only=false" 
                                               style="background-color: #1db954; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
                                                Review All Liked Songs
                                            </a>
                                        </div>
                                    {% else %}
                                        <p>You've reached the end of your liked songs.</p>
                                        <div style="margin-top: 20px;">
                                            <a href="/tag-liked-songs?offset=0&untagged_only=true" 
                                               style="background-color: #1db954; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
                                                Start Over - Untagged Only
                                            </a>
                                        </div>
                                    {% endif %}
                                </div>
                            {% elif current_song %}
                                <!-- Current liked song display -->
                                <div style="max-width: 90%; margin: 0 auto;">
                                    
                                    <!-- Audio Features Display - Hidden but functional for triangles -->
                                    <div id="audio-features-{{ current_song.db_id }}" style="visibility: hidden; height: 0; margin: 0; padding: 0;">
                                        <span style="margin-right: 20px;">Tempo: <strong id="display-tempo-{{ current_song.db_id }}">Loading...</strong></span>
                                        <span>Energy: <strong id="display-energy-{{ current_song.db_id }}">Loading...</strong></span>
                                    </div>
                                    
                                    <!-- Spotify widget with navigation -->
                                    <div style="margin-bottom: 20px;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <!-- Previous Song Button -->
                                            <button id="prev-btn" onclick="navigateToPrevSong()" 
                                                    style="background-color: #6c757d; color: white; width: 40px; height: 152px; display: flex; align-items: center; justify-content: center; text-decoration: none; border-radius: 8px; font-size: 24px; font-weight: bold; transition: background-color 0.2s; border: none; padding: 0; margin: 0; outline: none; cursor: pointer;"
                                                    onmouseover="this.style.backgroundColor='#5a6268'" 
                                                    onmouseout="this.style.backgroundColor='#6c757d'">
                                                ◀
                                            </button>

                                            <!-- Spotify Preview (unchanged) -->
                                            <iframe src="https://open.spotify.com/embed/track/{{ current_song.id }}?utm_source=generator&theme=0" 
                                                    width="100%" 
                                                    height="152" 
                                                    frameBorder="0" 
                                                    allowfullscreen="" 
                                                    allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
                                                    loading="lazy"
                                                    style="border-radius: 12px; flex: 1;" id="spotify-iframe">
                                            </iframe>

                                            <!-- Next Song Button -->
                                            <button id="next-btn" onclick="navigateToNextSong()" 
                                                    style="background-color: #1db954; color: white; width: 40px; height: 152px; display: flex; align-items: center; justify-content: center; text-decoration: none; border-radius: 8px; font-size: 24px; font-weight: bold; transition: background-color 0.2s; border: none; padding: 0; margin: 0; outline: none; cursor: pointer;"
                                                    onmouseover="this.style.backgroundColor='#17a245'" 
                                                    onmouseout="this.style.backgroundColor='#1db954'">
                                                ▶
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <!-- Song Attributes Section -->
                                    <div style="margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 8px;">
                                        <div class="sliders-container" style="gap: 15px;">
                                            <!-- Tempo Slider -->
                                            <div class="slider-group">
                                                <label class="slider-label" style="font-size: 11px; min-width: 40px;">Tempo:</label>
                                                <div class="slider-container small">
                                                    <div id="tempo-triangle-{{ current_song.db_id }}" class="triangle-indicator"></div>
                                                    <input type="range" 
                                                        class="attribute-slider small"
                                                        id="tempo-slider-{{ current_song.db_id }}"
                                                        min="1" 
                                                        max="5" 
                                                        value="3" 
                                                        step="1"
                                                        onchange="updateAttribute({{ current_song.db_id }}, 'tempo', this.value)">
                                                </div>
                                                <span id="tempo-label-{{ current_song.db_id }}" class="slider-value" style="font-size: 10px; min-width: 50px;">(Medium)</span>
                                            </div>
                                            
                                            <!-- Energy Slider -->
                                            <div class="slider-group">
                                                <label class="slider-label" style="font-size: 11px; min-width: 40px;">Energy:</label>
                                                <div class="slider-container small">
                                                    <div id="energy-triangle-{{ current_song.db_id }}" class="triangle-indicator"></div>
                                                    <input type="range" 
                                                        class="attribute-slider small"
                                                        id="energy-slider-{{ current_song.db_id }}"
                                                        min="1" 
                                                        max="5" 
                                                        value="3" 
                                                        step="1"
                                                        onchange="updateAttribute({{ current_song.db_id }}, 'energy', this.value)">
                                                </div>
                                                <span id="energy-label-{{ current_song.db_id }}" class="slider-value" style="font-size: 10px; min-width: 50px;">(Medium)</span>
                                            </div>
                                            
                                            <!-- Emotion Slider (was Mood) -->
                                            <div class="slider-group">
                                                <label class="slider-label" style="font-size: 11px; min-width: 40px;">Emotion:</label>
                                                <div class="slider-container small">
                                                    <div id="emotion-triangle-{{ current_song.db_id }}" class="triangle-indicator"></div>
                                                    <input type="range" 
                                                        class="attribute-slider small"
                                                        id="emotion-slider-{{ current_song.db_id }}"
                                                        min="1" 
                                                        max="5" 
                                                        value="3" 
                                                        step="1"
                                                        onchange="updateAttribute({{ current_song.db_id }}, 'mood', this.value)">
                                                </div>
                                                <span id="emotion-label-{{ current_song.db_id }}" class="slider-value" style="font-size: 10px; min-width: 50px;">(Chill/Neutral)</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Active tags -->
                                    <div id="active-tags-{{ current_song.db_id }}" style="margin-bottom: 15px;">
                                        <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Active Tags:</div>
                                        {% if current_song.tags %}
                                            {% for tag in current_song.tags %}
                                                <span style="display: inline-flex; align-items: center; background-color: #1db954; color: white; padding: 4px 12px; border-radius: 15px; font-size: 12px; margin: 2px; font-weight: 500;">
                                                    {{ tag.name }}
                                                    <button onclick="removeTag({{ current_song.db_id }}, {{ tag.id }})" 
                                                            style="background: none; border: none; color: white; cursor: pointer; font-size: 14px; padding: 0; margin-left: 5px;">×</button>
                                                </span>
                                            {% endfor %}
                                        {% else %}
                                            <span style="color: #999; font-size: 12px; font-style: italic;">No tags yet</span>
                                        {% endif %}
                                    </div>
                                    
                                    <!-- Search and add tags -->
                                    <div style="margin-bottom: 15px;">
                                        <div style="display: flex; gap: 6px; margin-bottom: 10px; align-items: center;">
                                            <input type="text" 
                                                   class="tag-search" 
                                                   data-song-id="{{ current_song.db_id }}"
                                                   placeholder="Search tags..." 
                                                   style="flex: 1; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px;">
                                            <button class="create-tag-btn" 
                                                    data-song-id="{{ current_song.db_id }}"
                                                    style="background-color: #1db954; color: white; border: none; padding: 6px 10px; border-radius: 4px; font-size: 10px; cursor: pointer; display: none;">
                                                Create
                                            </button>
                                            <button onclick="openTagManager()" 
                                                    style="background-color: #6c757d; color: white; border: none; padding: 6px 10px; border-radius: 4px; font-size: 10px; cursor: pointer; white-space: nowrap;">
                                                Manage Tags
                                            </button>
                                        </div>
                                        
                                        <!-- Available tags -->
                                        <div class="available-tags-container" data-song-id="{{ current_song.db_id }}" data-current-tags="{% for tag in current_song.tags %}{{ tag.id }}{% if not loop.last %},{% endif %}{% endfor %}">
                                            <div class="available-tags" style="max-height: 210px; overflow-y: auto; padding: 10px; background-color: #f8f9fa; border-radius: 5px; border: 1px solid #e9ecef;">
                                                <span style="color: #999; font-size: 11px;">Loading tags...</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                </div>
                            {% endif %}

                        {% elif tracks %}
                            <!-- Tag Liked Songs Navigation Button -->
                            <div style="margin-bottom: 15px;">
                                <button onclick="navigateToTagLikedSongs()" 
                                        style="background-color: #1db954; color: white; padding: 8px 15px; border: none; border-radius: 5px; font-size: 13px; font-weight: 500; width: 100%; cursor: pointer;">
                                    ← Back to Tag Liked Songs
                                </button>
                            </div>

                            <!-- Playlist Header with Description -->
                            <div style="margin-bottom: 15px;">
                                <h4 style="margin: 0 0 8px 0; color: #333;">{{ selected_playlist.name }} - {{ tracks|length }} songs</h4>
                                {% if playlist_description %}
                                    <div style="font-size: 12px; color: #666; font-style: italic; line-height: 1.4; padding: 8px 12px; background-color: #f8f9fa; border-radius: 5px; border-left: 3px solid #1db954;">
                                        {{ playlist_description }}
                                    </div>
                                {% endif %}
                            </div>
                            
                         
                            
                            <div style="max-height: 400px; overflow-y: auto; border: 1px solid #eee; border-radius: 5px;">
                                {% for track in tracks %}
                                    <div style="padding: 12px; border-bottom: 1px solid #f0f0f0; background-color: #fafafa;">
                                        <!-- Song info -->
                                        <div style="margin-bottom: 8px;">
                                            <div style="font-weight: 500; font-size: 14px; color: #333;">{{ track.name }}</div>
                                            <div style="color: #666; font-size: 12px;">{{ track.artist }} • {{ track.album }} • {{ track.duration }}</div>
                                        </div>
                                        
                                        <!-- Audio Features Display - Hidden but functional for triangles -->
                                        <div id="audio-features-{{ track.db_id }}" style="visibility: hidden; height: 0; margin: 0; padding: 0;">
                                            <span style="margin-right: 15px;">Tempo: <strong id="display-tempo-{{ track.db_id }}">Loading...</strong></span>
                                            <span>Energy: <strong id="display-energy-{{ track.db_id }}">Loading...</strong></span>
                                        </div>
                                        
                                        <!-- Spotify Embed Widget -->
                                        <iframe src="https://open.spotify.com/embed/track/{{ track.id }}?utm_source=generator&theme=0" 
                                                width="100%" 
                                                height="80" 
                                                frameBorder="0" 
                                                allowfullscreen="" 
                                                allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
                                                loading="lazy"
                                                style="border-radius: 8px; margin-bottom: 10px;">
                                        </iframe>
                                        
                                        <!-- Song Attributes Section (for playlist view) -->
                                        <div style="margin-bottom: 12px; padding: 10px; background-color: #f1f3f4; border-radius: 6px;">
                                            <div class="sliders-container" style="gap: 15px;">
                                                <!-- Tempo Slider -->
                                                <div class="slider-group">
                                                    <label class="slider-label" style="font-size: 10px; min-width: 35px;">Tempo:</label>
                                                    <div class="slider-container small">
                                                        <div id="tempo-triangle-{{ track.db_id }}" class="triangle-indicator"></div>
                                                        <input type="range" 
                                                            class="attribute-slider small"
                                                            id="tempo-slider-{{ track.db_id }}"
                                                            min="1" 
                                                            max="5" 
                                                            value="3" 
                                                            step="1"
                                                            onchange="updateAttribute({{ track.db_id }}, 'tempo', this.value)">
                                                    </div>
                                                    <span id="tempo-label-{{ track.db_id }}" class="slider-value" style="font-size: 9px; min-width: 45px;">(Medium)</span>
                                                </div>
                                                
                                                <!-- Energy Slider -->
                                                <div class="slider-group">
                                                    <label class="slider-label" style="font-size: 10px; min-width: 35px;">Energy:</label>
                                                    <div class="slider-container small">
                                                        <div id="energy-triangle-{{ track.db_id }}" class="triangle-indicator"></div>
                                                        <input type="range" 
                                                            class="attribute-slider small"
                                                            id="energy-slider-{{ track.db_id }}"
                                                            min="1" 
                                                            max="5" 
                                                            value="3" 
                                                            step="1"
                                                            onchange="updateAttribute({{ track.db_id }}, 'energy', this.value)">
                                                    </div>
                                                    <span id="energy-label-{{ track.db_id }}" class="slider-value" style="font-size: 9px; min-width: 45px;">(Medium)</span>
                                                </div>
                                                
                                                <!-- Emotion Slider (was Mood) -->
                                                <div class="slider-group">
                                                    <label class="slider-label" style="font-size: 10px; min-width: 35px;">Emotion:</label>
                                                    <div class="slider-container small">
                                                        <div id="emotion-triangle-{{ track.db_id }}" class="triangle-indicator"></div>
                                                        <input type="range" 
                                                            class="attribute-slider small"
                                                            id="emotion-slider-{{ track.db_id }}"
                                                            min="1" 
                                                            max="5" 
                                                            value="3" 
                                                            step="1"
                                                            onchange="updateAttribute({{ track.db_id }}, 'mood', this.value)">
                                                    </div>
                                                    <span id="emotion-label-{{ track.db_id }}" class="slider-value" style="font-size: 9px; min-width: 45px;">(Chill/Neutral)</span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Active tags section -->
                                        <div id="active-tags-{{ track.db_id }}" style="margin-bottom: 8px;">
                                            <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Active Tags:</div>
                                            {% if track.tags %}
                                                {% for tag in track.tags %}
                                                    <span style="display: inline-flex; align-items: center; background-color: #1db954; color: white; padding: 4px 10px; border-radius: 15px; font-size: 11px; margin: 2px; font-weight: 500;">
                                                        {{ tag.name }}
                                                        <button onclick="removeTag({{ track.db_id }}, {{ tag.id }})" 
                                                                style="background: none; border: none; color: white; cursor: pointer; font-size: 12px; padding: 0; margin-left: 3px;">×</button>
                                                    </span>
                                                {% endfor %}
                                            {% else %}
                                                <span style="color: #999; font-size: 11px; font-style: italic;">No active tags</span>
                                            {% endif %}
                                        </div>
                                        
                                        <!-- Search bar for tags -->
                                        <div style="margin-bottom: 8px;">
                                            <div style="display: flex; gap: 5px; align-items: center;">
                                                <input type="text" 
                                                       class="tag-search" 
                                                       data-song-id="{{ track.db_id }}"
                                                       placeholder="Search tags..." 
                                                       style="flex: 1; padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                                                <button class="create-tag-btn" 
                                                        data-song-id="{{ track.db_id }}"
                                                        style="background-color: #1db954; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 10px; cursor: pointer; display: none;">
                                                    Create
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <!-- Available tags -->
                                        <div class="available-tags-container" data-song-id="{{ track.db_id }}" data-current-tags="{% for tag in track.tags %}{{ tag.id }}{% if not loop.last %},{% endif %}{% endfor %}" style="margin-bottom: 8px;">
                                            <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Available Tags:</div>
                                            <div class="available-tags" style="max-height: 75px; overflow: hidden; line-height: 1.4;">
                                                <span style="color: #999; font-size: 10px;">Loading tags...</span>
                                            </div>
                                        </div>
                                    </div>
                                {% endfor %}
                            </div>
                            <div style="margin-top: 10px; text-align: center;">
                                <a href="/spotify" style="color: #666; font-size: 12px; text-decoration: none;">← Back to all playlists</a>
                            </div>
                        {% else %}
                            <!-- Empty state when no playlist selected and not in liked songs mode -->
                            <div style="text-align: center; color: #666; padding: 40px;">
                                <h4>Select a playlist or tag liked songs</h4>
                                <p>Click on any playlist from the sidebar to see its tracks here, or click "Tag Liked Songs" to start tagging your liked songs.</p>
                            </div>
                        {% endif %}
                    </div>
                    
                    <!-- Create Playlists Content (hidden by default) -->
                    <div id="create-playlists-content" style="display: none;">
                        <div style="max-width: 800px; margin: 0 auto; padding: 20px;">

                            <!-- Filter Controls Section -->
                            <div style="background-color: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                                
                                <!-- Three-slider container -->
                                <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                                    
                                    <!-- Tempo Range Slider -->
                                    <div style="flex: 1;">
                                        <div style="text-align: center; margin-bottom: 8px;">
                                            <label style="font-weight: 600; color: #495057; font-size: 12px;">Tempo</label>
                                        </div>
                                        
                                        <div class="range-slider-container" style="position: relative; height: 25px;">
                                            <div class="range-track" style="position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 3px; background: linear-gradient(to right, #20b2aa 0%, #20b2aa 25%, #ffd700 50%, #ff6347 75%, #ff6347 100%); border-radius: 2px;"></div>
                                            <div id="tempo-range-highlight" class="range-highlight" style="position: absolute; top: 50%; transform: translateY(-50%); height: 3px; background-color: #1db954; border-radius: 2px; left: 0%; width: 100%;"></div>
                                            <input type="range" id="tempo-min" class="range-slider-min" min="1" max="5" value="1" step="1" 
                                                style="position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 3px; background: transparent; outline: none; -webkit-appearance: none; appearance: none; pointer-events: auto; z-index: 1;">
                                            <input type="range" id="tempo-max" class="range-slider-max" min="1" max="5" value="5" step="1"
                                                style="position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 3px; background: transparent; outline: none; -webkit-appearance: none; appearance: none; pointer-events: auto; z-index: 2;">
                                        </div>
                                        
                                        <div style="display: flex; justify-content: space-between; margin-top: 2px; font-size: 8px; color: #666;">
                                            <span>VS</span><span>S</span><span>M</span><span>F</span><span>VF</span>
                                        </div>
                                        
                                        <div style="text-align: center; margin-top: 6px;">
                                            <span id="tempo-range-display" style="font-size: 11px; color: #666; background-color: white; padding: 1px 6px; border-radius: 10px; border: 1px solid #dee2e6;">
                                                Very Slow to Very Fast
                                            </span>
                                        </div>
                                    </div>
                                    
                                    <!-- Energy Range Slider -->
                                    <div style="flex: 1;">
                                        <div style="text-align: center; margin-bottom: 8px;">
                                            <label style="font-weight: 600; color: #495057; font-size: 12px;">Energy</label>
                                        </div>
                                        
                                        <div class="range-slider-container" style="position: relative; height: 25px;">
                                            <div class="range-track" style="position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 3px; background: linear-gradient(to right, #20b2aa 0%, #20b2aa 25%, #ffd700 50%, #ff6347 75%, #ff6347 100%); border-radius: 2px;"></div>
                                            <div id="energy-range-highlight" class="range-highlight" style="position: absolute; top: 50%; transform: translateY(-50%); height: 3px; background-color: #1db954; border-radius: 2px; left: 0%; width: 100%;"></div>
                                            <input type="range" id="energy-min" class="range-slider-min" min="1" max="5" value="1" step="1" 
                                                style="position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 3px; background: transparent; outline: none; -webkit-appearance: none; appearance: none; pointer-events: auto; z-index: 1;">
                                            <input type="range" id="energy-max" class="range-slider-max" min="1" max="5" value="5" step="1"
                                                style="position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 3px; background: transparent; outline: none; -webkit-appearance: none; appearance: none; pointer-events: auto; z-index: 2;">
                                        </div>
                                        
                                        <div style="display: flex; justify-content: space-between; margin-top: 2px; font-size: 8px; color: #666;">
                                            <span>VL</span><span>L</span><span>M</span><span>H</span><span>VH</span>
                                        </div>
                                        
                                        <div style="text-align: center; margin-top: 6px;">
                                            <span id="energy-range-display" style="font-size: 11px; color: #666; background-color: white; padding: 1px 6px; border-radius: 10px; border: 1px solid #dee2e6;">
                                                Very Low to Very High
                                            </span>
                                        </div>
                                    </div>
                                    
                                    <!-- Emotion Range Slider -->
                                    <div style="flex: 1;">
                                        <div style="text-align: center; margin-bottom: 8px;">
                                            <label style="font-weight: 600; color: #495057; font-size: 12px;">Emotion</label>
                                        </div>
                                        
                                        <div class="range-slider-container" style="position: relative; height: 25px;">
                                            <div class="range-track" style="position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 3px; background: linear-gradient(to right, #20b2aa 0%, #20b2aa 25%, #ffd700 50%, #ff6347 75%, #ff6347 100%); border-radius: 2px;"></div>
                                            <div id="emotion-range-highlight" class="range-highlight" style="position: absolute; top: 50%; transform: translateY(-50%); height: 3px; background-color: #1db954; border-radius: 2px; left: 0%; width: 100%;"></div>
                                            <input type="range" id="emotion-min" class="range-slider-min" min="1" max="5" value="1" step="1" 
                                                style="position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 3px; background: transparent; outline: none; -webkit-appearance: none; appearance: none; pointer-events: auto; z-index: 1;">
                                            <input type="range" id="emotion-max" class="range-slider-max" min="1" max="5" value="5" step="1"
                                                style="position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 3px; background: transparent; outline: none; -webkit-appearance: none; appearance: none; pointer-events: auto; z-index: 2;">
                                        </div>
                                        
                                        <div style="display: flex; justify-content: space-between; margin-top: 2px; font-size: 8px; color: #666;">
                                            <span>E</span><span>M</span><span>N</span><span>H</span><span>U</span>
                                        </div>
                                        
                                        <div style="text-align: center; margin-top: 6px;">
                                            <span id="emotion-range-display" style="font-size: 11px; color: #666; background-color: white; padding: 1px 6px; border-radius: 10px; border: 1px solid #dee2e6;">
                                                Emotional to Uplifting
                                            </span>
                                        </div>
                                    </div>
                                    
                                </div>
                                
                                <!-- Tag Selection Section -->
                                <div style="margin-top: 20px; padding: 15px; background-color: #ffffff; border-radius: 8px; border: 1px solid #dee2e6; position: relative;">
    
                                    <!-- Exclude Mode Toggle - positioned in top right -->
                                    <div style="position: absolute; top: 12px; right: 15px; display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 12px; color: #666;">Don't include</span>
                                        <label style="position: relative; display: inline-block; width: 40px; height: 20px;">
                                            <input type="checkbox" id="exclude-mode-toggle" onchange="toggleExcludeMode()" style="opacity: 0; width: 0; height: 0;">
                                            <span class="exclude-toggle-slider" style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px;"></span>
                                            <span class="exclude-toggle-circle" style="position: absolute; content: ''; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%;"></span>
                                        </label>
                                    </div>
                                    
                                    <!-- Tag Categories -->
                                    <div style="max-height: 550px; overflow-y: auto; margin-bottom: 15px;">
                                        <!-- Context/Vibe Section -->
                                        <div style="margin-bottom: 15px;">
                                            <div style="font-size: 10px; color: #666; font-weight: 600; margin: 8px 0 6px 0; text-transform: uppercase; letter-spacing: 0.5px;">Context/Vibe</div>
                                            <div id="playlist-context-list" style="padding: 8px; background-color: #f8f9fa; border-radius: 5px; border: 1px solid #e9ecef; min-height: 40px;">
                                                <span style="color: #999; font-size: 11px;">Loading tags...</span>
                                            </div>
                                        </div>
                                        
                                        <!-- Instrumentation Section -->
                                        <div style="margin-bottom: 15px;">
                                            <div style="font-size: 10px; color: #666; font-weight: 600; margin: 8px 0 6px 0; text-transform: uppercase; letter-spacing: 0.5px;">Instrumentation</div>
                                            <div id="playlist-instrumentation-list" style="padding: 8px; background-color: #f8f9fa; border-radius: 5px; border: 1px solid #e9ecef; min-height: 40px;">
                                                <span style="color: #999; font-size: 11px;">Loading tags...</span>
                                            </div>
                                        </div>
                                        
                                        <!-- Genre Sub Tag Section -->
                                        <div style="margin-bottom: 15px;">
                                            <div style="font-size: 10px; color: #666; font-weight: 600; margin: 8px 0 6px 0; text-transform: uppercase; letter-spacing: 0.5px;">Genre Sub Tag</div>
                                            <div id="playlist-genre-sub-list" style="padding: 8px; background-color: #f8f9fa; border-radius: 5px; border: 1px solid #e9ecef; min-height: 40px;">
                                                <span style="color: #999; font-size: 11px;">Loading tags...</span>
                                            </div>
                                        </div>
                                        
                                        <!-- Genre Section -->
                                        <div>
                                            <div style="font-size: 10px; color: #666; font-weight: 600; margin: 8px 0 6px 0; text-transform: uppercase; letter-spacing: 0.5px;">Genre</div>
                                            <div id="playlist-genre-list" style="padding: 8px; background-color: #f8f9fa; border-radius: 5px; border: 1px solid #e9ecef; min-height: 40px;">
                                                <span style="color: #999; font-size: 11px;">Loading tags...</span>
                                            </div>
                                        </div>

                                        <!-- Favourite Section (ADD THIS HERE) -->
                                        <div style="margin-bottom: 15px;">
                                            <div style="font-size: 10px; color: #666; font-weight: 600; margin: 8px 0 6px 0; text-transform: uppercase; letter-spacing: 0.5px;">Favourite</div>
                                            <div id="playlist-favourite-list" style="padding: 8px; background-color: #f8f9fa; border-radius: 5px; border: 1px solid #e9ecef; min-height: 40px;">
                                                <span style="color: #999; font-size: 11px;">Loading tags...</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                </div>
                            </div>
                            
                            
                        </div>
                    </div>
                    
                </div>
            </div>
            
            <!-- Right column: Conditional content based on active tab -->
            <div style="flex: 1;">
                
                <!-- Content for Tag Songs tab (normal sidebar) -->
                <div id="tag-songs-sidebar" style="display: block;">

                    <!-- Import All Songs button -->
                    <div style="text-align: center; margin-bottom: 15px;">
                        <button id="import-all-songs-btn" onclick="importAllSongsToLiked()" 
                                style="background-color: #ffffff; color: #333; padding: 10px 20px; border: 2px solid #96cc9b; border-radius: 5px; font-size: 14px; font-weight: 500; width: 100%; cursor: pointer; box-sizing: border-box;">
                            Import All Songs To Liked Songs
                        </button>
                    </div>

                    <!-- Import progress display -->
                    <div id="import-progress" style="display: none; margin-bottom: 15px; padding: 10px; background-color: #e7f3ff; border-radius: 5px; font-size: 12px;">
                        <div style="margin-bottom: 5px;">
                            <span id="import-status">Starting import...</span>
                        </div>
                        <div style="background-color: #dee2e6; border-radius: 3px; height: 6px; overflow: hidden;">
                            <div id="import-progress-bar" style="background-color: #1db954; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                        </div>
                        <div style="font-size: 10px; color: #666; margin-top: 3px;">
                            <span id="import-details">Processed: 0 songs</span>
                        </div>
                    </div>
                    
                    <!-- Search Liked Songs Section -->
                    <div style="background-color: white; padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                        <h5 style="margin-top: 0; margin-bottom: 10px; font-size: 14px;">Search Liked Songs</h5>
                        
                        <!-- Cache status indicator -->
                        <div id="cache-status" style="font-size: 10px; color: #666; margin-bottom: 5px; min-height: 12px;"></div>
                        
                        <input type="text" 
                            id="liked-songs-search" 
                            placeholder="Search your liked songs..." 
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 12px; box-sizing: border-box;"
                            disabled>
                        
                        <!-- Search Results Dropdown -->
                        <div id="search-results" style="position: relative; background-color: white; border: 1px solid #ddd; border-top: none; border-radius: 0 0 5px 5px; max-height: 200px; overflow-y: auto; display: none; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                            <!-- Results will be populated here -->
                        </div>
                    </div>
                    
                    <!-- Your Playlists section with toggle -->
                    <div style="background-color: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                        {% if playlist_error %}
                            <h4 style="margin-top: 0;">Your Playlists</h4>
                            <div style="background-color: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px; font-size: 12px;">
                                <p><strong>Error:</strong> {{ playlist_error }}</p>
                            </div>
                        {% elif playlists %}
                            <h4 style="margin-top: 0;">Your Playlists ({{ playlists|length }})</h4>
                            
                            <!-- Search input -->
                            <input type="text" 
                                id="playlist-search" 
                                placeholder="Search playlists..." 
                                style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 5px; font-size: 12px; box-sizing: border-box;">
                            
                            <!-- Display/Hide button (full width, below search) -->
                            <button id="toggle-playlists-btn" onclick="togglePlaylistsDisplay()" 
                                    style="background-color: #1db954; color: white; border: none; padding: 8px; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 500; width: 100%; margin-bottom: 10px;">
                                Display Playlists
                            </button>
                            
                            <!-- Playlists container (hidden by default) -->
                            <div id="playlists-container" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px; display: none;">
                                {% for playlist in playlists %}
                                    <div class="playlist-item" style="padding: 8px 10px; border-bottom: 1px solid #e9ecef;">
                                        <a href="/playlist/{{ playlist.id }}" 
                                        style="color: #555; text-decoration: none; font-weight: 600; font-size: 14px; display: block; margin-bottom: 2px;">
                                            {{ playlist.name }}
                                        </a>
                                        <div style="color: #888; font-size: 11px;">
                                            {{ playlist.track_count }} songs
                                        </div>
                                    </div>
                                {% endfor %}
                            </div>
                            
                        {% else %}
                            <h4 style="margin-top: 0;">Your Playlists</h4>
                            <div style="background-color: #fff3cd; color: #856404; padding: 10px; border-radius: 5px; font-size: 12px;">
                                <p>No playlists found.</p>
                            </div>
                        {% endif %}
                    </div>
                    
                    
                    <!-- Logout button -->
                    <div style="text-align: center;">
                        <a href="/logout" style="background-color: rgb(255, 255, 255); color: #333; padding: 8px 16px; text-decoration: none; border-radius: 5px; font-size: 12px; display: block; border: 2px solid #acacac;">
                            Logout from Spotify
                        </a>
                    </div>
                    
                </div>
                
                <!-- Content for Create Playlists tab (filtered songs) -->
                <div id="create-playlists-sidebar" style="display: none;">
                    
                    <!-- Results Section -->
                    <div id="playlist-results-section" style="display: none;">
                        <div style="background-color: white; padding: 20px; border-radius: 10px; height: calc(100vh - 100px); min-height: 600px; display: flex; flex-direction: column;">

                            
                            <!-- Header -->
                            <div style="margin-bottom: 15px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px;">
                                <h5 style="color: #495057; margin: 0;">Filtered Songs (<span id="results-count">0</span>)</h5>
                            </div>
                            
                            <!-- Selected Tags Summary -->
                            <div id="selected-tags-display" style="margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 5px; border: 1px solid #e9ecef; flex-shrink: 0;">
                                <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Selected Tags:</div>
                                <div id="selected-tags-container" style="min-height: 18px;">
                                    <span style="color: #999; font-size: 11px; font-style: italic;">No tags selected</span>
                                </div>
                            </div>
                            
                            <!-- Scrollable Songs Container -->
                            <div id="filtered-songs-container" style="flex: 1; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 8px; background-color: white; margin-bottom: 15px;">
                                <!-- Filtered songs will appear here -->
                            </div>
                            
                            <!-- Create Playlist Section -->
                            <div style="padding: 15px; border-radius: 8px; flex-shrink: 0;">
                                <input type="text" id="new-playlist-name" placeholder="Enter playlist name..." 
                                    style="width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; box-sizing: border-box; margin-bottom: 8px;">
                                <button onclick="createPlaylistFromFiltered()" 
                                        style="background-color: #1db954; color: white; border: none; padding: 6px 12px; border-radius: 5px; font-size: 14px; font-weight: 500; cursor: pointer; width: 100%;">
                                    Create Playlist
                                </button>
                            </div>
                            
                        </div>
                    </div>
                    
                    <!-- Smart Playlists Auto-Refresh (moved to bottom) -->
                    <div id="smart-playlists-section" style="background-color: white; padding: 20px; border-radius: 10px; margin-top: 20px; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h5 style="color: #495057; margin: 0;">Smart Playlists</h5>
                            <button id="refresh-all-btn" onclick="refreshAllSmartPlaylists()" 
                                    style="background-color: #1db954; color: white; border: none; padding: 8px 16px; border-radius: 5px; font-size: 13px; cursor: pointer; font-weight: 500;">
                                Refresh All
                            </button>
                        </div>
                        
                        <div style="font-size: 11px; color: #666; margin-bottom: 15px; line-height: 1.4;">
                            Automatically finds all playlists created with filters and adds newly tagged songs that match their criteria.
                        </div>
                        
                        <!-- Loading state -->
                        <div id="refresh-all-loading" style="display: none; text-align: center; padding: 30px; color: #666; font-size: 12px;">
                            <div style="margin-bottom: 10px;">
                                <div style="display: inline-block; width: 20px; height: 20px; border: 2px solid #e9ecef; border-top-color: #1db954; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                            </div>
                            <div><em>Scanning and refreshing playlists...</em></div>
                            <div style="font-size: 10px; color: #888; margin-top: 5px;">This may take a moment</div>
                        </div>
                        
                        <!-- Results display -->
                        <div id="refresh-all-results" style="display: none;">
                            <!-- Results will be populated here -->
                        </div>
                        
                        <!-- Initial state -->
                        <div id="refresh-all-initial" style="text-align: center; padding: 20px; color: #666; font-size: 12px; font-style: italic;">
                            Click "Refresh All" to automatically update all your smart playlists
                        </div>
                    </div>
                    
                </div>
                
            </div>
            
        </div>
        
        <!-- JavaScript for tag functionality -->
        <script>
        // Global variables for caching and progress
        let isCacheLoaded = false;
        let cacheLoadPromise = null;
        let totalLikedSongs = 0;
        let totalUntaggedSongs = 0;
        let currentSongOffset = {{ offset if liked_songs_mode else 0 }};
        let currentSongId = {{ current_song.db_id if current_song else 'null' }};
        let currentUntaggedOnly = {{ 'true' if untagged_only else 'false' }};

        // Navigate to tag liked songs (ensures proper page state)
        function navigateToTagLikedSongs() {
            console.log('DEBUG - Navigating to tag liked songs');
            
            // Use window.location to ensure proper navigation
            window.location.href = '/tag-liked-songs';
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('DEBUG - DOMContentLoaded fired');
            loadAvailableTags();
            setupSearchFunctionality();
            
            // Always setup liked songs search since it's now in the sidebar
            setupLikedSongsSearch();
            
            // Setup playlist search functionality
            setupPlaylistSearch();
            
            // Start loading cache immediately on page load
            loadLikedSongsCache();
            
            // Load song attributes for all visible songs
            loadAllSongAttributes();
            
            // Load audio features for all visible songs
            loadAllAudioFeatures();
            
            // Restore toggle state from sessionStorage if it exists
            restoreToggleState();

            // Restore toggle state from sessionStorage if it exists
            restoreToggleState();
            
            // Start preloading next song in background (add this line)
            setTimeout(preloadNextSong, 2000); // Wait 2 seconds after page load
            
            console.log('DEBUG - All initialization complete');
            
            console.log('DEBUG - All initialization complete');
        });

        // NEW: Fix ghosting by replicating the exact backend interaction that works manually
        function fixSliderGhostingViaBackend() {
            console.log('DEBUG - Manual ghosting fix via backend interaction triggered');
            
            // Find the first song
            const firstActiveTagsSection = document.querySelector('[id^="active-tags-"]');
            
            if (firstActiveTagsSection) {
                const songId = firstActiveTagsSection.id.replace('active-tags-', '');
                console.log(`DEBUG - Using song ${songId} for ghosting fix`);
                
                // Step 1: Add a temporary tag (this creates backend change + DOM update)
                console.log('DEBUG - Step 1: Adding temporary tag');
                fetch('/add-tag', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: `song_id=${songId}&tag_name=temp_ghosting_fix`
                })
                .then(response => {
                    if (response.ok) {
                        console.log('DEBUG - Step 1 complete: Temporary tag added');
                        
                        // Step 2: Remove the temporary tag after a short delay
                        setTimeout(() => {
                            console.log('DEBUG - Step 2: Finding and removing temporary tag');
                            
                            // Get the current tags to find the temp tag ID
                            fetch(`/get-song-tags/${songId}`)
                                .then(response => response.json())
                                .then(data => {
                                    const tempTag = data.tags.find(tag => tag.name === 'temp_ghosting_fix');
                                    if (tempTag) {
                                        console.log(`DEBUG - Found temp tag with ID ${tempTag.id}, removing it`);
                                        
                                        // Remove the temporary tag
                                        fetch('/remove-tag', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/x-www-form-urlencoded',
                                            },
                                            body: `song_id=${songId}&tag_id=${tempTag.id}`
                                        })
                                        .then(response => {
                                            if (response.ok) {
                                                console.log('DEBUG - Step 2 complete: Temporary tag removed');
                                                console.log('DEBUG - Full ghosting fix cycle complete - check sliders now');
                                            } else {
                                                console.log('DEBUG - Failed to remove temporary tag');
                                            }
                                        })
                                        .catch(error => {
                                            console.error('Error removing temp tag:', error);
                                        });
                                    } else {
                                        console.log('DEBUG - Temp tag not found for removal');
                                    }
                                })
                                .catch(error => {
                                    console.error('Error getting tags for temp tag removal:', error);
                                });
                        }, 500); // Wait 500ms before removing
                        
                    } else {
                        console.log('DEBUG - Failed to add temporary tag');
                    }
                })
                .catch(error => {
                    console.error('Error adding temp tag:', error);
                });
                
            } else {
                console.log('DEBUG - No songs found to trigger ghosting fix');
            }
        }

        // Classification functions for tempo and energy
        function classifyTempo(bpm) {
            if (bpm < 80) return 1;      // Very Low: < 80 BPM
            if (bpm < 100) return 2;     // Low: 80-100 BPM  
            if (bpm < 120) return 3;     // Medium: 100-120 BPM
            if (bpm < 140) return 4;     // High: 120-140 BPM
            return 5;                    // Very High: 140+ BPM
        }

        function classifyEnergy(energy) {
            if (energy < 0.2) return 1;    // Very Low: 0-0.2
            if (energy < 0.4) return 2;    // Low: 0.2-0.4
            if (energy < 0.6) return 3;    // Medium: 0.4-0.6  
            if (energy < 0.8) return 4;    // High: 0.6-0.8
            return 5;                      // Very High: 0.8-1.0
        }

        // Add this new function:
        function classifyMood(valence) {
            if (valence < 0.2) return 1;    // Emotional: 0-0.2
            if (valence < 0.4) return 2;    // Moody: 0.2-0.4
            if (valence < 0.6) return 3;    // Chill/Neutral: 0.4-0.6  
            if (valence < 0.8) return 4;    // Happy: 0.6-0.8
            return 5;                      // Uplifting: 0.8-1.0
        }

        // Show triangle indicator at the classified position - handles both regular and small triangles
        function showTriangleIndicator(songId, attributeType, classifiedValue) {
            // Try to find the triangle element
            const triangleElement = document.getElementById(`${attributeType}-triangle-${songId}`);
            
            console.log(`DEBUG - Looking for triangle: ${attributeType}-triangle-${songId}, found:`, !!triangleElement);
            
            if (triangleElement) {
                // Remove existing position classes
                triangleElement.classList.remove('pos-1', 'pos-2', 'pos-3', 'pos-4', 'pos-5', 'visible');
                
                // Add the new position class and make visible
                triangleElement.classList.add(`pos-${classifiedValue}`, 'visible');
                
                console.log(`DEBUG - Triangle for ${attributeType} song ${songId} positioned at ${classifiedValue}`);
            } else {
                console.log(`DEBUG - Triangle element not found: ${attributeType}-triangle-${songId}`);
            }
        }

        // Load audio features for all songs on the page
        function loadAllAudioFeatures() {
            // Find all audio features displays to identify songs that need audio features loaded
            const audioFeatureElements = document.querySelectorAll('[id^="audio-features-"]');
            console.log(`DEBUG - Found ${audioFeatureElements.length} songs with audio features to load`);
            
            audioFeatureElements.forEach(element => {
                const songId = element.id.replace('audio-features-', '');
                loadAudioFeatures(songId);
            });
        }

        // Background preloading for next song
        function preloadNextSong() {
            // Only preload in liked songs mode
            if (!window.location.pathname.includes('/tag-liked-songs')) {
                return;
            }
            
            const untaggedToggle = document.getElementById('untagged-toggle');
            const untaggedOnly = untaggedToggle ? untaggedToggle.checked : false;
            
            console.log(`DEBUG - Starting background preload for next song after offset ${currentSongOffset}`);
            
            // Get next song info using tracked offset
            const params = new URLSearchParams({
                offset: currentSongOffset,
                untagged_only: untaggedOnly
            });
            
            fetch(`/get-next-song-info?${params}`)
                .then(response => response.json())
                .then(data => {
                    if (data.has_next && data.song_id) {
                        console.log(`DEBUG - Found next song: ${data.name} - ${data.artist} (DB ID: ${data.song_id})`);
                        
                        // Preload song attributes
                        preloadSongAttributes(data.song_id);
                        
                        // Preload audio features  
                        preloadAudioFeatures(data.song_id);
                        
                    } else if (data.searched_limit_reached) {
                        console.log('DEBUG - Reached search limit looking for next untagged song');
                    } else {
                        console.log('DEBUG - No next song found (end of liked songs)');
                    }
                })
                .catch(error => {
                    console.log('DEBUG - Error preloading next song:', error);
                    // Fail silently since this is background operation
                });
        }

        //Debug function to check current state
        function debugCurrentState() {
            console.log('=== CURRENT STATE DEBUG ===');
            console.log('currentSongOffset:', currentSongOffset);
            console.log('currentSongId:', currentSongId);
            console.log('currentUntaggedOnly:', currentUntaggedOnly);
            console.log('URL:', window.location.href);
            const toggle = document.getElementById('untagged-toggle');
            console.log('Toggle checked:', toggle ? toggle.checked : 'not found');
            console.log('========================');
        }

        // Load attributes for a specific song
        function loadSongAttributes(songId) {
            console.log(`DEBUG loadSongAttributes - Loading for song ${songId}`);
            
            fetch(`/get-song-attributes-with-status/${songId}`)
                .then(response => response.json())
                .then(data => {
                    console.log(`DEBUG loadSongAttributes - Retrieved data for song ${songId}:`, data);
                    console.log(`DEBUG loadSongAttributes - Retrieved data for song ${songId}:`, data);
                    console.log(`DEBUG loadSongAttributes - Data types: tempo=${typeof data.tempo}, energy=${typeof data.energy}, mood=${typeof data.mood}, is_unset=${data.is_unset}`);
                    
                    if (data.is_unset) {
                        console.log(`DEBUG - Song ${songId} has NULL attributes, applying Spotify recommendations`);
                        
                        // Apply Spotify recommendations for truly unset songs
                        fetch(`/get-audio-features/${songId}`)
                            .then(response => response.json())
                            .then(audioData => {
                                if (audioData.tempo !== undefined && audioData.energy !== undefined && audioData.valence !== undefined) {
                                    console.log(`DEBUG - Got audio features for song ${songId}, applying recommendations`);
                                    
                                    const recommendedTempo = classifyTempo(audioData.tempo);
                                    const recommendedEnergy = classifyEnergy(audioData.energy);
                                    const recommendedEmotion = classifyMood(audioData.valence);
                                    
                                    console.log(`DEBUG - Applying Spotify recommendations: tempo=${recommendedTempo}, energy=${recommendedEnergy}, emotion=${recommendedEmotion}`);
                                    
                                    // Update sliders with recommendations
                                    updateSliderDisplay(songId, 'tempo', recommendedTempo);
                                    updateSliderDisplay(songId, 'energy', recommendedEnergy);
                                    updateSliderDisplay(songId, 'emotion', recommendedEmotion);
                                    
                                    // Save recommendations to database
                                    fetch('/update-song-attributes', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/x-www-form-urlencoded',
                                        },
                                        body: `song_id=${songId}&tempo=${recommendedTempo}&energy=${recommendedEnergy}&mood=${recommendedEmotion}`
                                    })
                                    .then(response => response.json())
                                    .then(saveData => {
                                        if (saveData.success) {
                                            console.log(`DEBUG - Successfully saved recommended values for song ${songId}`);
                                        } else {
                                            console.error(`DEBUG - Failed to save recommended values: ${saveData.error}`);
                                        }
                                    });
                                } else {
                                    console.log(`DEBUG - No audio features available, using default 3s`);
                                    // No Spotify data available, set to 3 (Medium) and save
                                    updateSliderDisplay(songId, 'tempo', 3);
                                    updateSliderDisplay(songId, 'energy', 3);
                                    updateSliderDisplay(songId, 'emotion', 3);
                                    
                                    fetch('/update-song-attributes', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/x-www-form-urlencoded',
                                        },
                                        body: `song_id=${songId}&tempo=3&energy=3&mood=3`
                                    });
                                }
                            })
                            .catch(error => {
                                console.error('Error loading audio features:', error);
                                // Fallback to Medium (3)
                                updateSliderDisplay(songId, 'tempo', 3);
                                updateSliderDisplay(songId, 'energy', 3);
                                updateSliderDisplay(songId, 'emotion', 3);
                            });
                    } else {
                        console.log(`DEBUG - Song ${songId} has been set, using saved values: tempo=${data.tempo}, energy=${data.energy}, mood=${data.mood}`);
                        // Song has been set - use exact saved values (including 3 if user chose it)
                        updateSliderDisplay(songId, 'tempo', data.tempo);
                        updateSliderDisplay(songId, 'energy', data.energy);
                        updateSliderDisplay(songId, 'emotion', data.mood);
                    }
                })
                .catch(error => {
                    console.error('Error loading song attributes:', error);
                });
        }


        // Preload audio features (similar to loadAudioFeatures but silent)  
        function preloadAudioFeatures(songId) {
            fetch(`/get-audio-features/${songId}`)
                .then(response => response.json())
                .then(data => {
                    console.log(`DEBUG - Preloaded audio features for song ${songId}`);
                    // Data is now cached by browser/server
                })
                .catch(error => {
                    console.log(`DEBUG - Error preloading audio features for song ${songId}:`, error);
                });
        }

        // Load audio features for a specific song
        function loadAudioFeatures(songId) {
            const tempoElement = document.getElementById(`display-tempo-${songId}`);
            const energyElement = document.getElementById(`display-energy-${songId}`);
            const valenceElement = document.getElementById(`display-valence-${songId}`);
            
            if (!tempoElement || !energyElement) {
                console.log(`DEBUG - Audio feature elements not found for song ${songId}`);
                return;
            }
            
            fetch(`/get-audio-features/${songId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.tempo !== undefined && data.energy !== undefined) {
                        // Classify the Spotify values
                        const classifiedTempo = classifyTempo(data.tempo);
                        const classifiedEnergy = classifyEnergy(data.energy);
                        const classifiedEmotion = data.valence !== undefined ? classifyMood(data.valence) : 3;
                        
                        // Format displays with classification
                        const tempoDisplay = data.tempo ? 
                            `${Math.round(data.tempo * 10) / 10} BPM (${classifiedTempo})` : 'N/A';
                        const energyDisplay = data.energy ? 
                            `${Math.round(data.energy * 100) / 100} (${classifiedEnergy})` : 'N/A';
                        const valenceDisplay = data.valence !== undefined ? 
                            `${Math.round(data.valence * 100) / 100} (${classifiedEmotion})` : 'N/A';
                        
                        tempoElement.textContent = tempoDisplay;
                        energyElement.textContent = energyDisplay;
                        if (valenceElement) {
                            valenceElement.textContent = valenceDisplay;
                        }
                        
                        // Show triangle indicators at the classified positions
                        showTriangleIndicator(songId, 'tempo', classifiedTempo);
                        showTriangleIndicator(songId, 'energy', classifiedEnergy);
                        showTriangleIndicator(songId, 'emotion', classifiedEmotion);
                        
                        console.log(`DEBUG - Loaded audio features for song ${songId}: tempo=${tempoDisplay}, energy=${energyDisplay}, emotion=${valenceDisplay}, cached=${data.cached}`);
                    } else {
                        tempoElement.textContent = 'N/A';
                        energyElement.textContent = 'N/A';
                        if (valenceElement) {
                            valenceElement.textContent = 'N/A';
                        }
                        console.log(`DEBUG - No audio features available for song ${songId}`);
                    }
                })
                .catch(error => {
                    console.error(`Error loading audio features for song ${songId}:`, error);
                    tempoElement.textContent = 'Error';
                    energyElement.textContent = 'Error';
                    if (valenceElement) {
                        valenceElement.textContent = 'Error';
                    }
                });
        }

        // Load attributes for all songs on the page
        function loadAllSongAttributes() {
            // Find all tempo sliders to identify songs that need attributes loaded
            const tempoSliders = document.querySelectorAll('[id^="tempo-slider-"]');
            console.log(`DEBUG - Found ${tempoSliders.length} songs with sliders to load attributes for`);
            
            tempoSliders.forEach(slider => {
                const songId = slider.id.replace('tempo-slider-', '');
                loadSongAttributes(songId);
                
                // Also initialize favourite button if it exists
                initializeFavouriteButton(songId);
            });
        }

        

        // Update attribute via AJAX - with extensive debugging
        function updateAttribute(songId, attributeType, value) {
            console.log(`DEBUG updateAttribute - START: songId=${songId}, attributeType=${attributeType}, value=${value}`);
            console.log(`DEBUG updateAttribute - Making fetch request to /update-song-attributes`);
            
            fetch('/update-song-attributes', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `song_id=${songId}&${attributeType}=${value}`
            })
            .then(response => {
                console.log(`DEBUG updateAttribute - Response status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                console.log(`DEBUG updateAttribute - Response data:`, data);
                if (data.success) {
                    console.log(`DEBUG updateAttribute - Success! Saved ${attributeType}=${value} for song ${songId}`);
                    updateSliderDisplay(songId, attributeType, value);
                    console.log(`DEBUG updateAttribute - updateSliderDisplay completed`);
                } else {
                    console.error('DEBUG updateAttribute - Error from server:', data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG updateAttribute - Fetch error:', error);
            });
            
            console.log(`DEBUG updateAttribute - END: fetch request sent`);
        }

        // Update slider display and label - force CSS re-render
        function updateSliderDisplay(songId, attributeType, value) {
            console.log(`DEBUG updateSliderDisplay - START: songId=${songId}, attributeType=${attributeType}, value=${value}`);
            
            // Map 'mood' to 'emotion' for DOM element lookup since we changed the frontend IDs
            const domAttributeType = attributeType === 'mood' ? 'emotion' : attributeType;
            
            const slider = document.getElementById(`${domAttributeType}-slider-${songId}`);
            const label = document.getElementById(`${domAttributeType}-label-${songId}`);
            
            if (slider) {
                console.log(`DEBUG updateSliderDisplay - Before update: slider.value=${slider.value}`);
                
                // Force complete CSS re-render by temporarily changing critical CSS properties
                const originalValue = slider.value;
                const originalBackground = slider.style.background;
                const originalAppearance = slider.style.appearance;
                
                // Step 1: Reset to browser default styling temporarily
                slider.style.appearance = 'auto';
                slider.style.background = 'none';
                slider.value = value;
                
                // Step 2: Force reflow
                slider.offsetWidth;
                
                // Step 3: Restore custom styling
                slider.style.appearance = originalAppearance || '';
                slider.style.background = originalBackground || '';
                
                // Step 4: Set value again after restoring styles
                slider.value = value;
                
                // Step 5: Force another reflow
                slider.offsetWidth;
                
                console.log(`DEBUG updateSliderDisplay - After CSS reset: slider.value=${slider.value}`);
            }
            
            if (label) {
                // Pass the original attribute type to get the correct label (so 'mood' gets emotion labels)
                const labelText = getAttributeLabel(parseInt(value), attributeType);
                label.textContent = labelText;
                console.log(`DEBUG updateSliderDisplay - Label updated to: ${labelText} for ${attributeType}`);
            }
            
            console.log(`DEBUG updateSliderDisplay - END`);
        }

        // Convert slider value to text label
        function getAttributeLabel(value, attributeType = '') {
            if (attributeType === 'tempo') {
                switch(value) {
                    case 1: return '(Very Slow)';
                    case 2: return '(Slow)';
                    case 3: return '(Medium)';
                    case 4: return '(Fast)';
                    case 5: return '(Very Fast)';
                    default: return '(Medium)';
                }
            } else if (attributeType === 'emotion' || attributeType === 'mood') {
                switch(value) {
                    case 1: return '(Emotional)';
                    case 2: return '(Moody)';
                    case 3: return '(Neutral)';
                    case 4: return '(Happy)';
                    case 5: return '(Uplifting)';
                    default: return '(Neutral)';
                }
            } else {
                // Energy and any other attributes use the original labels
                switch(value) {
                    case 1: return '(Very Low)';
                    case 2: return '(Low)';
                    case 3: return '(Medium)';
                    case 4: return '(High)';
                    case 5: return '(Very High)';
                    default: return '(Medium)';
                }
            }
        }

        // Handle tab switching
        function switchTab(tabName) {
            console.log('DEBUG - Switching to tab:', tabName);
            
            // Update tab buttons
            const tagSongsTab = document.getElementById('tag-songs-tab');
            const createPlaylistsTab = document.getElementById('create-playlists-tab');
            
            // Update content visibility
            const tagSongsContent = document.getElementById('tag-songs-content');
            const createPlaylistsContent = document.getElementById('create-playlists-content');
            
            // Update sidebar visibility
            const tagSongsSidebar = document.getElementById('tag-songs-sidebar');
            const createPlaylistsSidebar = document.getElementById('create-playlists-sidebar');
            
            // Get the column containers for width adjustment
            const leftColumn = document.querySelector('div[style*="flex: 2"]') || document.querySelector('div[style*="flex: 3"]');
            const rightColumn = leftColumn ? leftColumn.nextElementSibling : null;
            
            if (tabName === 'tag-songs') {
                // Activate Tag Songs tab
                tagSongsTab.style.color = '#1db954';
                tagSongsTab.style.borderBottomColor = '#1db954';
                createPlaylistsTab.style.color = '#666';
                createPlaylistsTab.style.borderBottomColor = 'transparent';
                
                // Show Tag Songs content and sidebar
                tagSongsContent.style.display = 'block';
                createPlaylistsContent.style.display = 'none';
                tagSongsSidebar.style.display = 'block';
                createPlaylistsSidebar.style.display = 'none';
                
                // Set column widths to 75%/25% for tag songs view
                if (leftColumn && rightColumn) {
                    leftColumn.style.flex = '3';
                    rightColumn.style.flex = '1';
                }
                
            } else if (tabName === 'create-playlists') {
                // Activate Create Playlists tab
                createPlaylistsTab.style.color = '#1db954';
                createPlaylistsTab.style.borderBottomColor = '#1db954';
                tagSongsTab.style.color = '#666';
                tagSongsTab.style.borderBottomColor = 'transparent';
                
                // Show Create Playlists content and sidebar
                createPlaylistsContent.style.display = 'block';
                tagSongsContent.style.display = 'none';
                tagSongsSidebar.style.display = 'none';
                createPlaylistsSidebar.style.display = 'block';
                
                // Set column widths to 2/3, 1/3 for create playlists view
                if (leftColumn && rightColumn) {
                    leftColumn.style.flex = '2';
                    rightColumn.style.flex = '1';
                }
                
                // Initialize dual range sliders, tags, and dynamic filtering when switching to this tab
                setTimeout(() => {
                    initializeDualRangeSliders();
                    
                    // Refresh tags from backend before initializing playlist tags
                    loadAvailableTags().then(() => {
                        initializePlaylistTags();
                        setupDynamicFiltering();
                        
                        // Ensure cache is loading before triggering filter
                        if (!isCacheLoaded && !cacheLoadPromise) {
                            console.log('DEBUG - Starting cache load for Create Playlists tab');
                            loadLikedSongsCache();
                        }
                        
                        // Trigger initial filter to show results immediately
                        triggerDynamicFilter();
                    });
                }, 50);
            }
        }

        // Setup the liked songs search functionality with caching
        function setupLikedSongsSearch() {
            console.log('DEBUG - setupLikedSongsSearch called');
            
            const searchInput = document.getElementById('liked-songs-search');
            const searchResults = document.getElementById('search-results');
            const cacheStatus = document.getElementById('cache-status');
            
            console.log('DEBUG - Elements found:', {
                searchInput: !!searchInput,
                searchResults: !!searchResults, 
                cacheStatus: !!cacheStatus
            });
            
            let searchTimeout = null;
            
            if (!searchInput || !searchResults || !cacheStatus) {
                console.log('DEBUG - Missing required elements, exiting');
                return;
            }
            
            console.log('DEBUG - Adding input event listener');
            searchInput.addEventListener('input', function(e) {
                console.log('DEBUG - Input event fired, value:', e.target.value);
                
                const query = e.target.value.trim();
                
                // Clear previous timeout
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                if (query.length < 2) {
                    console.log('DEBUG - Query too short, hiding results');
                    searchResults.style.display = 'none';
                    return;
                }
                
                console.log('DEBUG - Query long enough, processing...');
                
                // If cache isn't loaded yet, wait for it
                if (!isCacheLoaded) {
                    console.log('DEBUG - Cache not loaded yet, showing loading message');
                    searchResults.innerHTML = '<div style="padding: 10px; text-align: center; color: #666; font-size: 12px;">Loading cache...</div>';
                    searchResults.style.display = 'block';
                    
                    // Try again after cache loads
                    if (cacheLoadPromise) {
                        cacheLoadPromise.then(() => {
                            if (searchInput.value.trim() === query) {
                                console.log('DEBUG - Cache loaded, retrying search');
                                searchCachedLikedSongs(query);
                            }
                        });
                    }
                    return;
                }
                
                console.log('DEBUG - Cache is loaded, searching...');
                // Instant search through cached data
                searchTimeout = setTimeout(() => {
                    searchCachedLikedSongs(query);
                }, 100); // Much shorter delay since we're searching cached data
            });
            
            // Hide results when clicking outside
            document.addEventListener('click', function(e) {
                if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                    searchResults.style.display = 'none';
                }
            });
            
            console.log('DEBUG - setupLikedSongsSearch completed');
        }

        // Load and cache liked songs with real-time progress
        function loadLikedSongsCache() {
            console.log('DEBUG - loadLikedSongsCache called');
            const cacheStatus = document.getElementById('cache-status');
            const searchInput = document.getElementById('liked-songs-search');
            
            if (isCacheLoaded) {
                console.log('DEBUG - Cache already loaded');
                updateProgressDisplay();
                return Promise.resolve();
            }
            
            // Check if caching is already in progress
            if (cacheLoadPromise) {
                console.log('DEBUG - Cache loading already in progress, returning existing promise');
                return cacheLoadPromise;
            }
            
            if (cacheStatus) {
                cacheStatus.textContent = 'Loading liked songs...';
            }
            if (searchInput) {
                searchInput.disabled = true;
            }
            
            console.log('DEBUG - Making fetch request to /cache-liked-songs');
            cacheLoadPromise = fetch('/cache-liked-songs')
                .then(response => {
                    console.log('DEBUG - Cache response received:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('DEBUG - Cache data received:', data);
                    
                    if (data.status === 'cached' || data.status === 'already_cached') {
                        // Success - cache is complete
                        isCacheLoaded = true;
                        totalLikedSongs = data.total_songs || data.count || 0;
                        totalUntaggedSongs = data.total_untagged || 0;
                        
                        if (cacheStatus) {
                            cacheStatus.textContent = `${data.count} liked songs cached`;
                        }
                        if (searchInput) {
                            searchInput.disabled = false;
                            searchInput.placeholder = 'Search your liked songs...';
                        }
                        console.log('DEBUG - Cache loaded successfully. Total:', totalLikedSongs, 'Untagged:', totalUntaggedSongs);
                        
                        updateProgressDisplay();
                        
                        // Auto-fade the status message
                        setTimeout(() => {
                            if (cacheStatus) {
                                cacheStatus.style.opacity = '0.5';
                            }
                        }, 3000);
                        
                    } else if (data.status === 'caching_in_progress') {
                        // Caching is in progress - start polling for progress
                        console.log('DEBUG - Cache is in progress, starting progress polling');
                        if (cacheStatus) {
                            cacheStatus.textContent = 'Loading liked songs...';
                        }
                        
                        return pollCacheProgress();
                        
                    } else {
                        // Actual failure
                        console.log('DEBUG - Cache loading failed:', data);
                        if (cacheStatus) {
                            cacheStatus.textContent = 'Cache loading failed';
                        }
                        if (searchInput) {
                            searchInput.disabled = false;
                            searchInput.placeholder = 'Search (cache failed)...';
                        }
                    }
                })
                .catch(error => {
                    console.error('Cache loading error:', error);
                    if (cacheStatus) {
                        cacheStatus.textContent = 'Cache loading failed';
                    }
                    if (searchInput) {
                        searchInput.disabled = false;
                        searchInput.placeholder = 'Search (cache failed)...';
                    }
                })
                .finally(() => {
                    // Only clear the promise if we're not polling
                    if (isCacheLoaded || cacheStatus?.textContent?.includes('failed')) {
                        cacheLoadPromise = null;
                    }
                });
            
            return cacheLoadPromise;
        }

        // Poll for caching progress updates
        function pollCacheProgress() {
            const cacheStatus = document.getElementById('cache-status');
            
            return new Promise((resolve, reject) => {
                const checkProgress = () => {
                    fetch('/get-cache-progress')
                        .then(response => response.json())
                        .then(data => {
                            console.log('DEBUG - Progress check:', data);
                            
                            if (data.status === 'caching' && data.songs_cached !== undefined) {
                                // Update status with current progress
                                if (cacheStatus) {
                                    cacheStatus.textContent = `${data.songs_cached} songs loaded...`;
                                }
                                
                                // Continue polling
                                setTimeout(checkProgress, 500); // Check every 500ms
                                
                            } else if (data.status === 'completed') {
                                // Caching finished, reload the cache result
                                console.log('DEBUG - Caching completed, getting final result');
                                
                                fetch('/cache-liked-songs')
                                    .then(response => response.json())
                                    .then(finalData => {
                                        if (finalData.status === 'cached') {
                                            isCacheLoaded = true;
                                            totalLikedSongs = finalData.total_songs || finalData.count || 0;
                                            totalUntaggedSongs = finalData.total_untagged || 0;
                                            
                                            if (cacheStatus) {
                                                cacheStatus.textContent = `${finalData.count} liked songs cached`;
                                            }
                                            
                                            const searchInput = document.getElementById('liked-songs-search');
                                            if (searchInput) {
                                                searchInput.disabled = false;
                                                searchInput.placeholder = 'Search your liked songs...';
                                            }
                                            
                                            updateProgressDisplay();
                                            resolve();
                                        }
                                    })
                                    .catch(reject);
                                    
                            } else if (data.status === 'error' || data.status === 'not_caching') {
                                if (cacheStatus) {
                                    cacheStatus.textContent = 'Cache loading failed';
                                }
                                reject(new Error('Caching failed'));
                                
                            } else {
                                // Continue polling for other statuses
                                setTimeout(checkProgress, 500);
                            }
                        })
                        .catch(error => {
                            console.error('Progress polling error:', error);
                            reject(error);
                        });
                };
                
                // Start polling
                checkProgress();
            });
        }

        // Update the progress display based on current state
        function updateProgressDisplay() {
            const progressElement = document.getElementById('song-progress');
            const untaggedToggle = document.getElementById('untagged-toggle');
            
            if (!progressElement || !isCacheLoaded) return;
            
            const currentOffset = {{ offset if liked_songs_mode else 0 }};
            const untaggedOnly = untaggedToggle ? untaggedToggle.checked : false;
            
            let progressText;
            if (untaggedOnly) {
                progressText = `Song ${currentOffset + 1}/${totalUntaggedSongs} (untagged only)`;
            } else {
                progressText = `Song ${currentOffset + 1}/${totalLikedSongs}`;
            }
            
            progressElement.textContent = progressText;
            console.log('DEBUG - Updated progress display:', progressText);
        }

        // Fast search through cached data
        function searchCachedLikedSongs(query) {
            console.log('DEBUG - searchCachedLikedSongs called with query:', query);
            const searchResults = document.getElementById('search-results');
            
            console.log('DEBUG - Making fetch request to /search-cached-liked-songs');
            fetch(`/search-cached-liked-songs?q=${encodeURIComponent(query)}`)
                .then(response => {
                    console.log('DEBUG - Search response received:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('DEBUG - Search data received:', data);
                    if (data.error) {
                        console.log('DEBUG - Cache search failed with error:', data.error);
                        searchResults.innerHTML = '<div style="padding: 10px; text-align: center; color: #dc3545; font-size: 12px;">Cache search failed. Try refreshing the page.</div>';
                        searchResults.style.display = 'block';
                        return;
                    }
                    console.log('DEBUG - About to display results:', data.results.length);
                    displaySearchResults(data.results || []);
                })
                .catch(error => {
                    console.error('Cached search error:', error);
                    searchResults.innerHTML = '<div style="padding: 10px; text-align: center; color: #dc3545; font-size: 12px;">Search error occurred. Try refreshing the page.</div>';
                    searchResults.style.display = 'block';
                });
        }

        // Display search results
        function displaySearchResults(results) {
            console.log('DEBUG - displaySearchResults called with', results.length, 'results');
            const searchResults = document.getElementById('search-results');
            
            if (!searchResults) {
                console.log('DEBUG - searchResults element not found!');
                return;
            }
            
            if (results.length === 0) {
                console.log('DEBUG - No results, showing no songs message');
                searchResults.innerHTML = '<div style="padding: 10px; text-align: center; color: #666; font-size: 12px;">No songs found</div>';
                searchResults.style.display = 'block';
                return;
            }
            
            console.log('DEBUG - Building HTML for', results.length, 'results');
            let html = '';
            results.forEach((song, index) => {
                console.log(`DEBUG - Processing song ${index + 1}:`, song.name);
                // Show current tags
                let tagsHtml = '';
                if (song.tags && song.tags.length > 0) {
                    song.tags.forEach(tag => {
                        tagsHtml += `<span style="background-color: #1db954; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-right: 3px;">${tag.name}</span>`;
                    });
                } else {
                    tagsHtml = '<span style="color: #999; font-size: 10px; font-style: italic;">No tags</span>';
                }
                
                html += `
                    <div onclick="jumpToSong(${song.position})" 
                         style="padding: 10px; border-bottom: 1px solid #f0f0f0; cursor: pointer; hover: background-color: #f8f9fa;"
                         onmouseover="this.style.backgroundColor='#f8f9fa'" 
                         onmouseout="this.style.backgroundColor='white'">
                        <div style="font-weight: 500; font-size: 13px; color: #333; margin-bottom: 3px;">${song.name}</div>
                        <div style="color: #666; font-size: 11px; margin-bottom: 4px;">${song.artist}</div>
                        <div style="font-size: 10px; color: #888;">Position: ${song.position + 1} | Tags: ${tagsHtml}</div>
                    </div>
                `;
            });
            
            console.log('DEBUG - Setting innerHTML and making visible');
            searchResults.innerHTML = html;
            searchResults.style.display = 'block';
            console.log('DEBUG - displaySearchResults completed');
        }

        // Jump to a specific song (now works from any view)
        function jumpToSong(position) {
            console.log('DEBUG - jumpToSong called with position:', position);
            // Always turn off the untagged filter and switch to liked songs mode
            window.location.href = `/tag-liked-songs?offset=${position}&untagged_only=false`;
        }

        function loadAvailableTags() {
            console.log('DEBUG - Loading available tags...');
            
            return fetch('/get-recent-tags')
                .then(response => response.json())
                .then(data => {
                    console.log(`DEBUG - Received ${data.tags.length} tags from backend:`, data.tags.map(t => t.name));
                    
                    // Always update the cache with fresh data
                    window.allTags = data.tags;
                    
                    // Determine if we should show categories based on current URL
                    const currentPath = window.location.pathname;
                    const showCategories = currentPath.includes('/tag-liked-songs');
                    
                    console.log(`DEBUG - Current path: ${currentPath}, showCategories: ${showCategories}`);
                    
                    // Update ALL available tags containers
                    const containers = document.querySelectorAll('.available-tags-container');
                    console.log(`DEBUG - Found ${containers.length} tag containers to populate`);
                    
                    containers.forEach((container, index) => {
                        console.log(`DEBUG - Populating tags for container ${index + 1} with categories: ${showCategories}`);
                        displayAvailableTags(container, data.tags, null, showCategories);
                    });
                    
                    // Also update tag manager if it's open
                    const modal = document.getElementById('tag-manager-modal');
                    if (modal && modal.style.display !== 'none') {
                        console.log('DEBUG - Tag manager is open, refreshing it too');
                        loadTagsIntoManager();
                    }
                    
                    // Update playlist tags if in create playlist tab
                    const createPlaylistsContent = document.getElementById('create-playlists-content');
                    if (createPlaylistsContent && createPlaylistsContent.style.display !== 'none') {
                        console.log('DEBUG - Create playlists tab is active, refreshing playlist tags');
                        populatePlaylistTags();
                    }
                    
                    console.log(`DEBUG - Successfully loaded and cached ${data.tags.length} tags`);
                })
                .catch(error => {
                    console.error('ERROR - Failed to load available tags:', error);
                });
        }

        function displayAvailableTags(container, tags, filteredTags = null, showCategories = true) {
            const songId = container.getAttribute('data-song-id');
            const availableTagsDiv = container.querySelector('.available-tags');
            const currentTags = getCurrentTagsForSong(container);
            
            const tagsToShow = filteredTags || tags;
            
            if (tagsToShow.length === 0) {
                availableTagsDiv.innerHTML = '<span style="color: #999; font-size: 11px;">No tags available</span>';
                return;
            }
            
            const inactiveTags = tagsToShow.filter(tag => !currentTags.includes(tag.id.toString()));
            
            if (inactiveTags.length === 0) {
                availableTagsDiv.innerHTML = '<span style="color: #999; font-size: 11px;">All tags are active</span>';
                return;
            }
            
            let tagsHtml = '';
            
            if (showCategories) {
                // Show with category headers (for liked songs view) - ALWAYS use sorting
                // Separate tags by all 4 categories (exclude favourite from Tag Songs view)
                const contextTags = [];
                const instrumentationTags = [];
                const genreSubTags = [];
                const genreTags = [];
                
                inactiveTags.forEach(tag => {
                    const category = getTagCategory(tag.id);
                    // Skip favourite tags in Tag Songs view - they're handled by the button
                    if (category === 'favourite') {
                        return;
                    }
                    
                    if (category === 'context') {
                        contextTags.push(tag);
                    } else if (category === 'instrumentation') {
                        instrumentationTags.push(tag);
                    } else if (category === 'genre-sub') {
                        genreSubTags.push(tag);
                    } else if (category === 'genre') {
                        genreTags.push(tag);
                    }
                });
                
                // ALWAYS sort each category by custom order
                const sortedContext = sortTagsByOrder(contextTags, 'context');
                const sortedInstrumentation = sortTagsByOrder(instrumentationTags, 'instrumentation');
                const sortedGenreSub = sortTagsByOrder(genreSubTags, 'genre-sub');
                const sortedGenre = sortTagsByOrder(genreTags, 'genre');
                
                // Context/Vibe section (first)
                if (sortedContext.length > 0) {
                    tagsHtml += '<div style="font-size: 10px; color: #666; font-weight: 600; margin: 8px 0 4px 0; text-transform: uppercase; letter-spacing: 0.5px;">Context/Vibe</div>';
                    sortedContext.forEach(tag => {
                        tagsHtml += `
                            <button onclick="addTag(${songId}, ${tag.id}, '${tag.name}')" 
                                    style="background-color: #e9ecef; color: #495057; border: 1px solid #ced4da; padding: 3px 8px; border-radius: 12px; font-size: 10px; margin: 1px; cursor: pointer;">
                                ${tag.name}
                            </button>
                        `;
                    });
                }
                
                // Instrumentation section (second)
                if (sortedInstrumentation.length > 0) {
                    tagsHtml += '<div style="font-size: 10px; color: #666; font-weight: 600; margin: 8px 0 4px 0; text-transform: uppercase; letter-spacing: 0.5px;">Instrumentation</div>';
                    sortedInstrumentation.forEach(tag => {
                        tagsHtml += `
                            <button onclick="addTag(${songId}, ${tag.id}, '${tag.name}')" 
                                    style="background-color: #e9ecef; color: #495057; border: 1px solid #ced4da; padding: 3px 8px; border-radius: 12px; font-size: 10px; margin: 1px; cursor: pointer;">
                                ${tag.name}
                            </button>
                        `;
                    });
                }
                
                // Genre Sub Tag section
                if (sortedGenreSub.length > 0) {
                    tagsHtml += '<div style="font-size: 10px; color: #666; font-weight: 600; margin: 8px 0 4px 0; text-transform: uppercase; letter-spacing: 0.5px;">Genre Sub Tag</div>';
                    sortedGenreSub.forEach(tag => {
                        tagsHtml += `
                            <button onclick="addTag(${songId}, ${tag.id}, '${tag.name}')" 
                                    style="background-color: #e9ecef; color: #495057; border: 1px solid #ced4da; padding: 3px 8px; border-radius: 12px; font-size: 10px; margin: 1px; cursor: pointer;">
                                ${tag.name}
                            </button>
                        `;
                    });
                }
                
                // Genre section
                if (sortedGenre.length > 0) {
                    tagsHtml += '<div style="font-size: 10px; color: #666; font-weight: 600; margin: 8px 0 4px 0; text-transform: uppercase; letter-spacing: 0.5px;">Genre</div>';
                    sortedGenre.forEach(tag => {
                        tagsHtml += `
                            <button onclick="addTag(${songId}, ${tag.id}, '${tag.name}')" 
                                    style="background-color: #e9ecef; color: #495057; border: 1px solid #ced4da; padding: 3px 8px; border-radius: 12px; font-size: 10px; margin: 1px; cursor: pointer;">
                                ${tag.name}
                            </button>
                        `;
                    });
                }
                
            } else {
                // Show flat list without categories (for playlist view) - also sort
                const sortedTags = inactiveTags.sort((a, b) => a.name.localeCompare(b.name));
                sortedTags.forEach(tag => {
                    tagsHtml += `
                        <button onclick="addTag(${songId}, ${tag.id}, '${tag.name}')" 
                                style="background-color: #e9ecef; color: #495057; border: 1px solid #ced4da; padding: 3px 8px; border-radius: 12px; font-size: 10px; margin: 1px; cursor: pointer;">
                            ${tag.name}
                        </button>
                    `;
                });
            }
            
            if (tagsHtml === '') {
                tagsHtml = '<span style="color: #999; font-size: 11px;">No available tags</span>';
            }
            
            availableTagsDiv.innerHTML = tagsHtml;
        }

        function setupSearchFunctionality() {
            // Handle ALL tag search inputs, not just the first one
            const searchInputs = document.querySelectorAll('.tag-search');
            const createBtns = document.querySelectorAll('.create-tag-btn');
            
            console.log(`DEBUG - Found ${searchInputs.length} tag search inputs`);
            
            searchInputs.forEach((searchInput, index) => {
                const createBtn = createBtns[index]; // Get corresponding create button
                const songId = searchInput.dataset.songId;
                const container = document.querySelector(`.available-tags-container[data-song-id="${songId}"]`);
                
                console.log(`DEBUG - Setting up search for song ${songId}`);
                
                if (searchInput && container) {
                    searchInput.addEventListener('input', function(e) {
                        const originalInput = e.target.value.trim(); // Preserve original case
                        const searchTerm = originalInput.toLowerCase(); // Lowercase only for searching
                        
                        // Determine if we should show categories based on URL
                        const showCategories = window.location.pathname.includes('/tag-liked-songs');
                        
                        if (searchTerm === '') {
                            displayAvailableTags(container, window.allTags || [], null, showCategories);
                            if (createBtn) createBtn.style.display = 'none';
                            return;
                        }
                        
                        const filteredTags = (window.allTags || []).filter(tag => 
                            tag.name.toLowerCase().includes(searchTerm)
                        );
                        
                        displayAvailableTags(container, window.allTags || [], filteredTags, showCategories);
                        
                        const exactMatch = (window.allTags || []).some(tag => 
                            tag.name.toLowerCase() === searchTerm
                        );
                        
                        if (!exactMatch && searchTerm.length > 0 && createBtn) {
                            createBtn.style.display = 'block';
                            createBtn.textContent = `Create "${originalInput}"`;
                            createBtn.onclick = function() {
                                createAndAddTag(songId, originalInput);
                            };
                        } else if (createBtn) {
                            createBtn.style.display = 'none';
                        }
                    });
                    
                    // Also trigger the initial display of available tags for this song
                    if (window.allTags) {
                        const showCategories = window.location.pathname.includes('/tag-liked-songs');
                        displayAvailableTags(container, window.allTags, null, showCategories);
                    }
                }
            });
        }

        function toggleUntaggedOnly() {
            const checkbox = document.getElementById('untagged-toggle');
            const isChecked = checkbox.checked;
            
            console.log(`DEBUG - Toggle untagged filter: ${isChecked}, current offset: ${currentSongOffset}`);
            
            // Store the toggle state in session
            sessionStorage.setItem('untaggedOnly', isChecked);
            
            // Update global state
            currentUntaggedOnly = isChecked;
            
            // Update toggle visuals immediately
            updateToggleVisuals(checkbox, isChecked);
            
            // Navigate to current position with new filter
            loadSongAjax(currentSongOffset, isChecked);
        }

        // Add this new function to handle toggle visuals
        function updateToggleVisuals(toggle, isChecked) {
            const slider = toggle.nextElementSibling; // the .toggle-slider span
            const circle = slider.nextElementSibling; // the .toggle-circle span
            
            if (slider) {
                slider.style.backgroundColor = isChecked ? '#1db954' : '#ccc';
            }
            if (circle) {
                circle.style.left = isChecked ? '16px' : '2px';
            }
            
            console.log(`DEBUG - Updated toggle visuals: checked=${isChecked}`);
        }

        function updateNavigationButtons() {
            const toggle = document.getElementById('untagged-toggle');
            if (!toggle) return;
            
            const offset = {{ offset if liked_songs_mode else 0 }};
            const untaggedOnly = toggle.checked ? 'true' : 'false';  // Convert boolean to string
            
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            
            console.log(`DEBUG - Updating navigation buttons: untaggedOnly=${untaggedOnly}, offset=${offset}`);
            
            if (prevBtn) {
                prevBtn.href = `/prev-liked-song?offset=${offset}&untagged_only=${untaggedOnly}`;
                console.log(`DEBUG - Updated prev button URL: ${prevBtn.href}`);
            }
            if (nextBtn) {
                nextBtn.href = `/next-liked-song?offset=${offset}&untagged_only=${untaggedOnly}`;
                console.log(`DEBUG - Updated next button URL: ${nextBtn.href}`);
            }
        }

        // Restore the toggle state from sessionStorage
        function restoreToggleState() {
            const savedState = sessionStorage.getItem('untaggedOnly');
            const toggle = document.getElementById('untagged-toggle');
            
            if (savedState !== null && toggle) {
                const shouldBeChecked = savedState === 'true';
                
                // Only update if it differs from current state
                if (toggle.checked !== shouldBeChecked) {
                    console.log(`DEBUG - Restoring toggle state to: ${shouldBeChecked}`);
                    toggle.checked = shouldBeChecked;
                    
                    // Update the visual state of the toggle
                    updateToggleVisuals(toggle, shouldBeChecked);
                }
                
                // Always update navigation buttons to match current toggle state
                updateNavigationButtons();
            }
        }

        // Update the visual appearance of the toggle
        function updateToggleVisuals(toggle, isChecked) {
            const slider = toggle.nextElementSibling; // the .toggle-slider span
            const circle = slider.nextElementSibling; // the .toggle-circle span
            
            if (slider) {
                slider.style.backgroundColor = isChecked ? '#1db954' : '#ccc';
            }
            if (circle) {
                circle.style.left = isChecked ? '16px' : '2px';
            }
        }

        function getCurrentTagsForSong(container) {
            const currentTagsAttr = container.getAttribute('data-current-tags');
            if (!currentTagsAttr || currentTagsAttr === '') {
                return [];
            }
            return currentTagsAttr.split(',');
        }

        function createAndAddTag(songId, tagName) {
            console.log(`DEBUG - Creating and adding tag: ${tagName} for song ${songId}`);
            
            fetch('/add-tag', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `song_id=${songId}&tag_name=${encodeURIComponent(tagName)}`
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`DEBUG - Successfully created/added tag: ${tagName}`);
                    
                    // Hide the create button first
                    const createBtn = document.querySelector(`.create-tag-btn[data-song-id="${songId}"]`);
                    if (createBtn) {
                        createBtn.style.display = 'none';
                    }
                    
                    // CRITICAL: Force complete cache refresh BUT maintain URL-based display
                    console.log('DEBUG - Forcing complete tag cache refresh...');
                    window.allTags = null; // Clear cache to force reload
                    
                    // Determine display mode based on URL BEFORE refreshing
                    const showCategories = window.location.pathname.includes('/tag-liked-songs');
                    console.log(`DEBUG - URL-based showCategories: ${showCategories} (path: ${window.location.pathname})`);
                    
                    loadAvailableTags().then(() => {
                        console.log('DEBUG - Cache refreshed, now refreshing specific song tags...');
                        
                        // Refresh this specific song's tags with correct display mode
                        fetch(`/get-song-tags/${songId}`)
                            .then(response => response.json())
                            .then(songTagData => {
                                updateActiveTagsDisplay(songId, songTagData.tags);
                                
                                const container = document.querySelector(`.available-tags-container[data-song-id="${songId}"]`);
                                if (container) {
                                    const tagIds = songTagData.tags.map(tag => tag.id).join(',');
                                    container.setAttribute('data-current-tags', tagIds);
                                    
                                    // Use the URL-based detection we determined earlier
                                    console.log(`DEBUG - Displaying tags for song ${songId} with showCategories: ${showCategories}`);
                                    displayAvailableTags(container, window.allTags || [], null, showCategories);
                                }
                                
                                // CLEAR THE INPUT AFTER EVERYTHING IS COMPLETE
                                const searchInput = document.querySelector(`.tag-search[data-song-id="${songId}"]`);
                                if (searchInput) {
                                    searchInput.value = '';
                                    console.log(`DEBUG - Cleared search input for song ${songId}`);
                                }
                                
                            })
                            .catch(error => {
                                console.error('Error refreshing song tags:', error);
                                
                                // Still clear the input even if refresh fails
                                const searchInput = document.querySelector(`.tag-search[data-song-id="${songId}"]`);
                                if (searchInput) {
                                    searchInput.value = '';
                                }
                            });
                    });
                } else {
                    console.error('ERROR - Failed to create/add tag:', data.error);
                }
            })
            .catch(error => {
                console.error('ERROR - Exception creating/adding tag:', error);
            });
        }

        function addTag(songId, tagId, tagName) {
            fetch('/add-tag', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `song_id=${songId}&tag_name=${encodeURIComponent(tagName)}`
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('DEBUG - Tag added successfully via AJAX');
                    refreshTagsForSong(songId);
                } else {
                    console.error('Error adding tag:', data.error);
                }
            })
            .catch(error => {
                console.error('Error adding tag:', error);
            });
        }

        function removeTag(songId, tagId) {
            fetch('/remove-tag', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `song_id=${songId}&tag_id=${tagId}`
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('DEBUG - Tag removed successfully via AJAX');
                    refreshTagsForSong(songId);
                } else {
                    console.error('Error removing tag:', data.error);
                }
            })
            .catch(error => {
                console.error('Error removing tag:', error);
            });
        }

        function refreshTagsForSong(songId) {
            fetch(`/get-song-tags/${songId}`)
                .then(response => response.json())
                .then(data => {
                    updateActiveTagsDisplay(songId, data.tags);
                    
                    const container = document.querySelector(`.available-tags-container[data-song-id="${songId}"]`);
                    if (container) {
                        const tagIds = data.tags.map(tag => tag.id).join(',');
                        container.setAttribute('data-current-tags', tagIds);
                        
                        // Use URL-based detection to determine if we should show categories
                        const showCategories = window.location.pathname.includes('/tag-liked-songs');
                        displayAvailableTags(container, window.allTags || [], null, showCategories);
                    }
                })
                .catch(error => {
                    console.error('Error refreshing tags:', error);
                });
        }

        function updateActiveTagsDisplay(songId, tags) {
            const activeTagsSection = document.getElementById(`active-tags-${songId}`);
            
            if (!activeTagsSection) return;
            
            let activeTagsHtml = '<div style="font-size: 11px; color: #666; margin-bottom: 4px;">Active Tags:</div>';
            
            if (tags.length === 0) {
                activeTagsHtml += '<span style="color: #999; font-size: 11px; font-style: italic;">No active tags</span>';
            } else {
                tags.forEach(tag => {
                    activeTagsHtml += `
                        <span style="display: inline-flex; align-items: center; background-color: #1db954; color: white; padding: 4px 10px; border-radius: 15px; font-size: 11px; margin: 2px; font-weight: 500;">
                            ${tag.name}
                            <button onclick="removeTag(${songId}, ${tag.id})" 
                                    style="background: none; border: none; color: white; cursor: pointer; font-size: 12px; padding: 0; margin-left: 3px;">×</button>
                        </span>
                    `;
                });
            }
            
            activeTagsSection.innerHTML = activeTagsHtml;
        }

        // Tag Management Modal Functions
        function openTagManager() {
            console.log('DEBUG - Opening tag manager');
            const modal = document.getElementById('tag-manager-modal');
            if (modal) {
                modal.style.display = 'block';
                loadTagsIntoManager();
            } else {
                console.log('ERROR - Tag manager modal not found');
            }
        }
        
        function closeTagManager() {
            console.log('DEBUG - Closing tag manager and refreshing main displays');
            const modal = document.getElementById('tag-manager-modal');
            if (modal) {
                modal.style.display = 'none';
            }

            // Force refresh of all tag displays to show the new ordering
            console.log('DEBUG - Refreshing main tag displays with new ordering');
            loadAvailableTags().then(() => {
                console.log('DEBUG - Main tag displays refreshed successfully');
            });
        }
        
        function loadTagsIntoManager() {
            console.log('DEBUG - Loading tags into manager with drag and drop + sorting');
            const contextList = document.getElementById('context-list');
            const instrumentationList = document.getElementById('instrumentation-list');
            const genreSubList = document.getElementById('genre-sub-list');
            const genreList = document.getElementById('genre-list');
            
            if (window.allTags && window.allTags.length > 0) {
                // Separate tags by category first
                const contextTags = [];
                const instrumentationTags = [];
                const genreSubTags = [];
                const genreTags = [];
                
                window.allTags.forEach(tag => {
                    const category = getTagCategory(tag.id);
                    if (category === 'context') {
                        contextTags.push(tag);
                    } else if (category === 'instrumentation') {
                        instrumentationTags.push(tag);
                    } else if (category === 'genre-sub') {
                        genreSubTags.push(tag);
                    } else if (category === 'genre') {
                        genreTags.push(tag);
                    }
                });
                
                // Sort each category by custom order
                const sortedContext = sortTagsByOrder(contextTags, 'context');
                const sortedInstrumentation = sortTagsByOrder(instrumentationTags, 'instrumentation');
                const sortedGenreSub = sortTagsByOrder(genreSubTags, 'genre-sub');
                const sortedGenre = sortTagsByOrder(genreTags, 'genre');
                
                // Generate HTML for each category
                const generateTagHTML = (tag, category) => `
                    <span draggable="true" 
                        ondragstart="handleTagDragStart(event, ${tag.id}, '${tag.name}', '${category}')"
                        style="display: inline-flex; align-items: center; background-color: #e9ecef; color: #495057; padding: 4px 8px; border-radius: 12px; font-size: 11px; margin: 2px; border: 1px solid #ced4da; transition: all 0.2s; cursor: move;"
                        onmouseover="this.style.backgroundColor='#dee2e6'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)'" 
                        onmouseout="this.style.backgroundColor='#e9ecef'; this.style.transform='translateY(0px)'; this.style.boxShadow='none'"
                        ondragend="this.style.opacity='1'">
                        <span style="pointer-events: none;">${tag.name}</span>
                        <button onclick="confirmDeleteTag(${tag.id}, '${tag.name}')" style="background: none; border: none; color: #dc3545; cursor: pointer; font-size: 12px; padding: 0; margin-left: 4px; font-weight: bold;">×</button>
                    </span>
                `;
                
                const contextHtml = sortedContext.map(tag => generateTagHTML(tag, 'context')).join('');
                const instrumentationHtml = sortedInstrumentation.map(tag => generateTagHTML(tag, 'instrumentation')).join('');
                const genreSubHtml = sortedGenreSub.map(tag => generateTagHTML(tag, 'genre-sub')).join('');
                const genreHtml = sortedGenre.map(tag => generateTagHTML(tag, 'genre')).join('');
                
                // Update displays
                contextList.innerHTML = contextHtml || '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No context/vibe tags yet<br><small>Drag tags here and reorder by dragging within the section</small></div>';
                instrumentationList.innerHTML = instrumentationHtml || '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No instrumentation tags yet<br><small>Drag tags here and reorder by dragging within the section</small></div>';
                genreSubList.innerHTML = genreSubHtml || '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No genre sub tags yet<br><small>Drag tags here and reorder by dragging within the section</small></div>';
                genreList.innerHTML = genreHtml || '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No genre tags yet<br><small>Drag tags here and reorder by dragging within the section</small></div>';
                
                console.log(`DEBUG - Loaded sorted tags: ${contextHtml ? sortedContext.length : 0} context, ${instrumentationHtml ? sortedInstrumentation.length : 0} instrumentation, ${genreSubHtml ? sortedGenreSub.length : 0} genre-sub, ${genreHtml ? sortedGenre.length : 0} genre`);
            } else {
                contextList.innerHTML = '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No tags available</div>';
                instrumentationList.innerHTML = '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No tags available</div>';
                genreSubList.innerHTML = '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No tags available</div>';
                genreList.innerHTML = '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No tags available</div>';
            }
            
            // Setup drop zones
            setupDropZones();
        }

        // Enhanced drag and drop functionality with intra-category sorting
        let draggedTagData = null;

        function handleTagDragStart(event, tagId, tagName, currentCategory) {
            console.log(`DEBUG - Starting drag for tag: ${tagName} from ${currentCategory}`);
            draggedTagData = {
                id: tagId,
                name: tagName,
                currentCategory: currentCategory,
                dragElement: event.target
            };
            
            // Visual feedback
            event.target.style.opacity = '0.5';
            event.dataTransfer.effectAllowed = 'move';
        }

        function setupDropZones() {
            console.log('DEBUG - Setting up drop zones with horizontal insertion detection');
            
            const dropZones = [
                { element: document.getElementById('context-list'), category: 'context' },
                { element: document.getElementById('instrumentation-list'), category: 'instrumentation' },
                { element: document.getElementById('genre-sub-list'), category: 'genre-sub' },
                { element: document.getElementById('genre-list'), category: 'genre' }
            ];
            
            dropZones.forEach(zone => {
                if (zone.element) {
                    // Prevent default drag behaviors and show insertion indicators
                    zone.element.addEventListener('dragover', function(event) {
                        event.preventDefault();
                        event.dataTransfer.dropEffect = 'move';
                        
                        if (!draggedTagData) return;
                        
                        // Remove any existing insertion indicators
                        const existingIndicators = document.querySelectorAll('.drag-insertion-indicator');
                        existingIndicators.forEach(indicator => indicator.remove());
                        
                        if (draggedTagData.currentCategory !== zone.category) {
                            // Cross-category move - highlight the entire zone
                            this.style.backgroundColor = '#e3f2fd';
                            this.style.border = '2px dashed #1976d2';
                        } else {
                            // Intra-category move - show precise insertion point for specific row
                            this.style.backgroundColor = '#f0f8f0';
                            this.style.border = '2px dashed #4caf50';
                            
                            // Get all draggable elements in this zone (excluding the dragged one)
                            const draggableElements = [...this.querySelectorAll('span[draggable="true"]')].filter(el => {
                                const onDragStartAttr = el.getAttribute('ondragstart');
                                const tagIdMatch = onDragStartAttr.match(/handleTagDragStart\(event,\s*(\d+),/);
                                return tagIdMatch && parseInt(tagIdMatch[1]) !== draggedTagData.id;
                            });
                            
                            if (draggableElements.length === 0) {
                                // Empty category - show indicator in center
                                const zoneRect = this.getBoundingClientRect();
                                const insertionX = zoneRect.left + 10;
                                const insertionY = zoneRect.top + 10;
                                
                                createRowSpecificIndicator(this, insertionX - zoneRect.left, insertionY - zoneRect.top);
                                return;
                            }
                            
                            // Group elements by row based on Y position
                            const rows = [];
                            const rowTolerance = 10;
                            
                            draggableElements.forEach(element => {
                                const rect = element.getBoundingClientRect();
                                const elementY = rect.top;
                                
                                let targetRow = rows.find(row => Math.abs(row.y - elementY) <= rowTolerance);
                                
                                if (!targetRow) {
                                    targetRow = { 
                                        y: elementY, 
                                        height: rect.height,
                                        elements: [] 
                                    };
                                    rows.push(targetRow);
                                }
                                
                                targetRow.elements.push({
                                    element: element,
                                    rect: rect
                                });
                            });
                            
                            // Sort rows by Y position
                            rows.sort((a, b) => a.y - b.y);
                            
                            // Sort elements within each row by X position
                            rows.forEach(row => {
                                row.elements.sort((a, b) => a.rect.left - b.rect.left);
                            });
                            
                            // Determine which row the mouse is over
                            const mouseY = event.clientY;
                            let targetRow = null;
                            
                            for (let row of rows) {
                                const rowTop = row.y - 15;
                                const rowBottom = row.y + row.height + 15;
                                
                                if (mouseY >= rowTop && mouseY <= rowBottom) {
                                    targetRow = row;
                                    break;
                                }
                            }
                            
                            // If no specific row found, use the closest row
                            if (!targetRow) {
                                let closestDistance = Infinity;
                                rows.forEach(row => {
                                    const distance = Math.abs(mouseY - row.y);
                                    if (distance < closestDistance) {
                                        closestDistance = distance;
                                        targetRow = row;
                                    }
                                });
                            }
                            
                            if (!targetRow) return;
                            
                            // Find horizontal insertion point within the target row
                            const mouseX = event.clientX;
                            let insertionX = null;
                            let insertBeforeElement = null;
                            
                            for (let elementData of targetRow.elements) {
                                const elementCenterX = elementData.rect.left + elementData.rect.width / 2;
                                
                                if (mouseX < elementCenterX) {
                                    insertBeforeElement = elementData.element;
                                    insertionX = elementData.rect.left - 2;
                                    break;
                                }
                            }
                            
                            // If no insertion point found, insert at the end of the row
                            if (!insertBeforeElement && targetRow.elements.length > 0) {
                                const lastElement = targetRow.elements[targetRow.elements.length - 1];
                                insertionX = lastElement.rect.right + 2;
                            } else if (targetRow.elements.length === 0) {
                                // Empty row - show indicator at beginning
                                const zoneRect = this.getBoundingClientRect();
                                insertionX = zoneRect.left + 10;
                            }
                            
                            // Create row-specific indicator
                            if (insertionX !== null) {
                                const zoneRect = this.getBoundingClientRect();
                                const relativeX = insertionX - zoneRect.left;
                                const relativeY = targetRow.y - zoneRect.top;
                                
                                createRowSpecificIndicator(this, relativeX, relativeY, targetRow.height);
                            }
                        }
                    });
                    
                    zone.element.addEventListener('dragleave', function(event) {
                        // Only remove highlight if we're truly leaving the drop zone
                        const rect = this.getBoundingClientRect();
                        const x = event.clientX;
                        const y = event.clientY;
                        
                        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                            this.style.backgroundColor = '#fafafa';
                            this.style.border = '2px solid #dee2e6';
                            this.style.position = 'static'; // Reset positioning
                            
                            // Remove insertion indicators
                            const indicators = document.querySelectorAll('.drag-insertion-indicator');
                            indicators.forEach(indicator => indicator.remove());
                        }
                    });
                    
                    zone.element.addEventListener('drop', function(event) {
                        event.preventDefault();
                        
                        // Reset visual feedback
                        this.style.backgroundColor = '#fafafa';
                        this.style.border = '2px solid #dee2e6';
                        this.style.position = 'static'; // Reset positioning
                        
                        // Remove insertion indicators
                        const indicators = document.querySelectorAll('.drag-insertion-indicator');
                        indicators.forEach(indicator => indicator.remove());
                        
                        if (draggedTagData) {
                            console.log(`DEBUG - Dropping tag ${draggedTagData.name} into ${zone.category}`);
                            
                            if (draggedTagData.currentCategory === zone.category) {
                                // Intra-category reordering with horizontal positioning
                                handleHorizontalReorder(zone.element, event.clientX, event.clientY, zone.category);
                            } else {
                                // Cross-category move
                                moveTagToCategory(draggedTagData.id, draggedTagData.name, zone.category);
                            }
                            
                            draggedTagData = null;
                        }
                    });
                }
            });
        }

        // Create a row-specific drag insertion indicator
        function createRowSpecificIndicator(container, relativeX, relativeY, tagHeight = 30) {
            // Remove any existing indicators first
            const existingIndicators = container.querySelectorAll('.drag-insertion-indicator');
            existingIndicators.forEach(indicator => indicator.remove());
            
            const indicator = document.createElement('div');
            indicator.className = 'drag-insertion-indicator';
            
            // Position indicator for specific row only
            indicator.style.cssText = `
                position: absolute;
                left: ${relativeX}px;
                top: ${relativeY}px;
                width: 3px; 
                height: ${tagHeight}px;
                background: linear-gradient(180deg, #4caf50, #81c784, #4caf50); 
                border-radius: 2px;
                box-shadow: 0 0 6px rgba(76,175,80,0.6);
                animation: pulse 0.6s ease-in-out infinite alternate;
                z-index: 1000;
                pointer-events: none;
            `;
            
            // Ensure container has relative positioning
            container.style.position = 'relative';
            container.appendChild(indicator);
            
            console.log(`DEBUG - Created row-specific indicator at X:${relativeX}, Y:${relativeY}, height:${tagHeight}`);
        }

        // Helper function to find where to insert during drag - improved accuracy
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('span[draggable="true"]:not([style*="opacity: 0.5"])')];//Exclude the dragged element
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Handle horizontal reordering within the same category - fixed for multiple rows
        function handleHorizontalReorder(dropZone, clientX, clientY, category) {
            console.log(`DEBUG - Horizontal reordering within ${category} category at X:${clientX}, Y:${clientY}`);
            
            // Get all tag elements in this category (excluding the dragged one)
            const tagElements = [...dropZone.querySelectorAll('span[draggable="true"]')].filter(el => {
                const onDragStartAttr = el.getAttribute('ondragstart');
                const tagIdMatch = onDragStartAttr.match(/handleTagDragStart\(event,\s*(\d+),/);
                return tagIdMatch && parseInt(tagIdMatch[1]) !== draggedTagData.id;
            });
            
            if (tagElements.length === 0) {
                // Empty category or only dragged element - insert at beginning
                const newOrder = [draggedTagData.id];
                console.log(`DEBUG - Empty category, inserting at beginning`);
                setTagOrdering(category, newOrder);
                setTimeout(() => loadTagsIntoManager(), 100);
                return;
            }
            
            // Group elements by row based on their Y position
            const rows = [];
            const rowTolerance = 10; // Allow 10px variance for same row
            
            tagElements.forEach(element => {
                const rect = element.getBoundingClientRect();
                const elementY = rect.top;
                
                // Find existing row or create new one
                let targetRow = rows.find(row => Math.abs(row.y - elementY) <= rowTolerance);
                
                if (!targetRow) {
                    targetRow = { y: elementY, elements: [] };
                    rows.push(targetRow);
                }
                
                targetRow.elements.push({
                    element: element,
                    rect: rect,
                    tagId: parseInt(element.getAttribute('ondragstart').match(/handleTagDragStart\(event,\s*(\d+),/)[1])
                });
            });
            
            // Sort rows by Y position (top to bottom)
            rows.sort((a, b) => a.y - b.y);
            
            // Sort elements within each row by X position (left to right)
            rows.forEach(row => {
                row.elements.sort((a, b) => a.rect.left - b.rect.left);
            });
            
            console.log(`DEBUG - Found ${rows.length} rows with elements:`, rows.map(row => 
                `Row ${row.y}: [${row.elements.map(el => el.element.textContent.trim()).join(', ')}]`
            ));
            
            // Determine which row the mouse is over
            let targetRow = null;
            for (let row of rows) {
                // Check if mouse Y is within this row's bounds (with some tolerance)
                const rowTop = row.y - 15; // 15px above
                const rowBottom = row.y + 35; // Assume ~35px row height
                
                if (clientY >= rowTop && clientY <= rowBottom) {
                    targetRow = row;
                    break;
                }
            }
            
            // If no specific row found, use the closest row
            if (!targetRow) {
                let closestDistance = Infinity;
                rows.forEach(row => {
                    const distance = Math.abs(clientY - row.y);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        targetRow = row;
                    }
                });
            }
            
            console.log(`DEBUG - Target row: Y=${targetRow.y} with ${targetRow.elements.length} elements`);
            
            // Find horizontal insertion point within the target row
            let insertBeforeElement = null;
            
            for (let elementData of targetRow.elements) {
                const elementCenterX = elementData.rect.left + elementData.rect.width / 2;
                
                if (clientX < elementCenterX) {
                    insertBeforeElement = elementData.element;
                    console.log(`DEBUG - Insert before: ${elementData.element.textContent.trim()}`);
                    break;
                }
            }
            
            if (!insertBeforeElement) {
                console.log(`DEBUG - Insert at end of target row`);
            }
            
            // Build the new order array by going through all rows in order
            const newOrder = [];
            
            for (let row of rows) {
                for (let elementData of row.elements) {
                    // If this is our insertion point, insert dragged tag first
                    if (elementData.element === insertBeforeElement) {
                        newOrder.push(draggedTagData.id);
                        console.log(`DEBUG - Inserted ${draggedTagData.name} before ${elementData.element.textContent.trim()}`);
                    }
                    
                    // Add the current element
                    newOrder.push(elementData.tagId);
                }
            }
            
            // If we haven't inserted the dragged tag yet, add it at the end
            if (!newOrder.includes(draggedTagData.id)) {
                newOrder.push(draggedTagData.id);
                console.log(`DEBUG - Inserted ${draggedTagData.name} at end`);
            }
            
            console.log(`DEBUG - New order for ${category}:`, newOrder.map(id => {
                const tag = window.allTags?.find(t => t.id === id);
                return tag ? tag.name : `ID:${id}`;
            }));
            
            // Save the new order and refresh display
            setTagOrdering(category, newOrder);
            setTimeout(() => loadTagsIntoManager(), 100);
        }

        // Handle reordering within the same category
        function handleIntraCategoryReorder(dropZone, clientY, category) {
            console.log(`DEBUG - Reordering within ${category} category`);
            
            // Get all tag elements in this category
            const tagElements = [...dropZone.querySelectorAll('span[draggable="true"]')];
            const afterElement = getDragAfterElement(dropZone, clientY);
            
            console.log(`DEBUG - Found ${tagElements.length} tags in category, inserting ${draggedTagData.name} ${afterElement ? 'before ' + afterElement.textContent : 'at end'}`);
            
            // Build the new order based on insertion point
            const newOrder = [];
            let draggedTagInserted = false;
            
            tagElements.forEach(element => {
                // Extract tag ID from the ondragstart attribute
                const onDragStartAttr = element.getAttribute('ondragstart');
                const tagIdMatch = onDragStartAttr.match(/handleTagDragStart\(event,\s*(\d+),/);
                
                if (tagIdMatch) {
                    const tagId = parseInt(tagIdMatch[1]);
                    
                    // Skip the dragged tag in its original position
                    if (tagId === draggedTagData.id) {
                        return;
                    }
                    
                    // Insert dragged tag before this element if this is the afterElement
                    if (element === afterElement && !draggedTagInserted) {
                        newOrder.push(draggedTagData.id);
                        draggedTagInserted = true;
                        console.log(`DEBUG - Inserted ${draggedTagData.name} before ${element.textContent.trim()}`);
                    }
                    
                    // Add the current element's tag ID
                    newOrder.push(tagId);
                }
            });
            
            // If dragged tag wasn't inserted yet, add it at the end
            if (!draggedTagInserted) {
                newOrder.push(draggedTagData.id);
                console.log(`DEBUG - Inserted ${draggedTagData.name} at end`);
            }
            
            console.log(`DEBUG - New order for ${category}:`, newOrder);
            
            // Save the new order
            setTagOrdering(category, newOrder);
            
            // Refresh the display immediately
            loadTagsIntoManager();
        }

        // Improved intra-category reordering with better insertion logic
        function handleIntraCategoryReorderImproved(dropZone, clientY, category) {
            console.log(`DEBUG - Improved reordering within ${category} category`);
            
            // Get all tag elements in this category (excluding the dragged one)
            const tagElements = [...dropZone.querySelectorAll('span[draggable="true"]')].filter(el => {
                const onDragStartAttr = el.getAttribute('ondragstart');
                const tagIdMatch = onDragStartAttr.match(/handleTagDragStart\(event,\s*(\d+),/);
                return tagIdMatch && parseInt(tagIdMatch[1]) !== draggedTagData.id;
            });
            
            // Find insertion point based on mouse Y position
            let insertBeforeElement = null;
            
            for (let i = 0; i < tagElements.length; i++) {
                const element = tagElements[i];
                const rect = element.getBoundingClientRect();
                const elementCenterY = rect.top + rect.height / 2;
                
                if (clientY < elementCenterY) {
                    insertBeforeElement = element;
                    break;
                }
            }
            
            // Build the new order array
            const newOrder = [];
            let draggedTagInserted = false;
            
            // Insert dragged tag at the beginning if it should go before the first element
            if (insertBeforeElement === tagElements[0]) {
                newOrder.push(draggedTagData.id);
                draggedTagInserted = true;
                console.log(`DEBUG - Inserted ${draggedTagData.name} at beginning`);
            }
            
            // Process each existing tag element
            tagElements.forEach((element, index) => {
                // Extract tag ID from the ondragstart attribute
                const onDragStartAttr = element.getAttribute('ondragstart');
                const tagIdMatch = onDragStartAttr.match(/handleTagDragStart\(event,\s*(\d+),/);
                
                if (tagIdMatch) {
                    const tagId = parseInt(tagIdMatch[1]);
                    
                    // If this is our insertion point and we haven't inserted yet
                    if (element === insertBeforeElement && !draggedTagInserted) {
                        newOrder.push(draggedTagData.id);
                        draggedTagInserted = true;
                        console.log(`DEBUG - Inserted ${draggedTagData.name} before ${element.textContent.trim()}`);
                    }
                    
                    // Add the current element's tag ID
                    newOrder.push(tagId);
                }
            });
            
            // If we haven't inserted the dragged tag yet, add it at the end
            if (!draggedTagInserted) {
                newOrder.push(draggedTagData.id);
                console.log(`DEBUG - Inserted ${draggedTagData.name} at end`);
            }
            
            console.log(`DEBUG - New order for ${category}:`, newOrder.map(id => {
                const tag = window.allTags?.find(t => t.id === id);
                return tag ? tag.name : `ID:${id}`;
            }));
            
            // Save the new order
            setTagOrdering(category, newOrder);
            
            // Refresh the display immediately to show the new order
            setTimeout(() => {
                loadTagsIntoManager();
            }, 100);
        }

        function moveTagToCategory(tagId, tagName, newCategory) {
            console.log(`DEBUG - Moving tag ${tagName} to ${newCategory}`);
            
            // Update localStorage
            let tagCategories = getTagCategories();
            tagCategories[tagId] = newCategory;
            localStorage.setItem('tagCategories', JSON.stringify(tagCategories));
            
            console.log(`DEBUG - Tag ${tagName} moved to ${newCategory} successfully`);
            
            // Refresh the display
            loadTagsIntoManager();
        }
        
        function moveTag(tagId, tagName, currentCategory) {
            console.log(`DEBUG - Moving tag ${tagName} from ${currentCategory}`);
            
            // Get current categorization from localStorage
            let tagCategories = getTagCategories();
            
            // Move to opposite category
            const newCategory = currentCategory === 'descriptor' ? 'genre' : 'descriptor';
            tagCategories[tagId] = newCategory;
            
            // Save back to localStorage
            localStorage.setItem('tagCategories', JSON.stringify(tagCategories));
            
            console.log(`DEBUG - Moved tag ${tagName} to ${newCategory}`);
            
            // Refresh the display
            loadTagsIntoManager();
        }
        
        function getTagCategories() {
            try {
                const stored = localStorage.getItem('tagCategories');
                if (!stored) return {};
                
                const categories = JSON.parse(stored);
                
                // Validate categories - remove any with invalid category names
                const validCategories = ['context', 'instrumentation', 'genre-sub', 'genre'];
                const cleaned = {};
                
                Object.entries(categories).forEach(([tagId, category]) => {
                    if (validCategories.includes(category)) {
                        cleaned[tagId] = category;
                    } else {
                        console.log(`DEBUG - Removing invalid category "${category}" for tag ID ${tagId}`);
                    }
                });
                
                // Save cleaned version back to localStorage
                if (Object.keys(cleaned).length !== Object.keys(categories).length) {
                    localStorage.setItem('tagCategories', JSON.stringify(cleaned));
                    console.log('DEBUG - Cleaned up localStorage categories');
                }
                
                return cleaned;
            } catch (e) {
                console.log('DEBUG - Error reading tag categories from localStorage, clearing:', e);
                localStorage.removeItem('tagCategories');
                return {};
            }
        }
        
        function getTagCategory(tagId) {
            // Special handling for favourite tag
            const tag = window.allTags?.find(t => t.id === tagId);
            if (tag && tag.name.toLowerCase() === 'favourite') {
                return 'favourite';
            }
            
            const categories = getTagCategories();
            // Return the stored category, or default to 'context' for new tags
            return categories[tagId] || 'context';
        }

        function confirmDeleteTag(tagId, tagName) {
            console.log(`DEBUG - Confirming deletion of tag: ${tagName}`);
            
            // Create confirmation dialog
            if (confirm(`Are you sure you want to delete the tag "${tagName}"?\n\nThis will remove it from all songs and cannot be undone.`)) {
                deleteTag(tagId, tagName);
            }
        }
        
        function deleteTag(tagId, tagName) {
            console.log(`DEBUG - Deleting tag: ${tagName} (ID: ${tagId})`);
            
            fetch('/delete-tag', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `tag_id=${tagId}`
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`DEBUG - Successfully deleted tag: ${tagName}`);
                    
                    // Remove from localStorage categorization
                    let tagCategories = getTagCategories();
                    delete tagCategories[tagId];
                    localStorage.setItem('tagCategories', JSON.stringify(tagCategories));
                    
                    // Remove from global tags list
                    if (window.allTags) {
                        window.allTags = window.allTags.filter(tag => tag.id !== parseInt(tagId));
                    }
                    
                    // Refresh tag manager display
                    loadTagsIntoManager();
                    
                    // Refresh available tags in the main view
                    loadAvailableTags();
                    
                    // Refresh active tags for current song (if in liked songs mode)
                    const activeTagsSection = document.querySelector('[id^="active-tags-"]');
                    if (activeTagsSection) {
                        const songId = activeTagsSection.id.replace('active-tags-', '');
                        refreshTagsForSong(songId);
                        console.log(`DEBUG - Refreshed active tags for song ${songId}`);
                    }
                    
                } else {
                    console.error('Error deleting tag:', data.error);
                    alert(`Error deleting tag: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error deleting tag:', error);
                alert('An error occurred while deleting the tag.');
            });
        }

        function initializeDualRangeSliders() {
            console.log('DEBUG - Initializing dual range sliders');
            
            // Initialize tempo range slider
            setupDualRangeSlider('tempo');
            
            // Initialize energy range slider  
            setupDualRangeSlider('energy');
            
            // Initialize emotion range slider
            setupDualRangeSlider('emotion');
        }

        function setupDualRangeSlider(attributeType) {
            const minSlider = document.getElementById(`${attributeType}-min`);
            const maxSlider = document.getElementById(`${attributeType}-max`);
            const rangeDisplay = document.getElementById(`${attributeType}-range-display`);
            const rangeHighlight = document.getElementById(`${attributeType}-range-highlight`);
            
            if (!minSlider || !maxSlider || !rangeDisplay || !rangeHighlight) {
                console.log(`DEBUG - Missing elements for ${attributeType} range slider`);
                return;
            }
            
            console.log(`DEBUG - Setting up ${attributeType} range slider with native behavior`);
            
            // Function to update display and highlight
            function updateRangeDisplay() {
                let minVal = parseInt(minSlider.value);
                let maxVal = parseInt(maxSlider.value);
                
                // Ensure min is never greater than max
                if (minVal > maxVal) {
                    [minVal, maxVal] = [maxVal, minVal];
                    minSlider.value = minVal;
                    maxSlider.value = maxVal;
                }
                
                // Update display text with attribute-specific labels
                const minText = getAttributeLabel(minVal, attributeType).replace('(', '').replace(')', '');
                const maxText = getAttributeLabel(maxVal, attributeType).replace('(', '').replace(')', '');

                if (minVal === maxVal) {
                    rangeDisplay.textContent = minText;
                } else {
                    rangeDisplay.textContent = `${minText} to ${maxText}`;
                }
                
                // Update range highlight - INVERTED LOGIC
                // Green areas show what's EXCLUDED, gradient shows what's INCLUDED
                const minPercent = ((minVal - 1) / 4) * 100;
                const maxPercent = ((maxVal - 1) / 4) * 100;
                
                // Force a reflow to ensure the update happens
                rangeHighlight.offsetWidth;
                
                // Use CSS to create two grey sections (excluded areas) with gradient in between
                if (minVal === 1 && maxVal === 5) {
                    // Full range selected - no grey overlay needed
                    rangeHighlight.style.background = 'transparent';
                } else {
                    // Create a gradient background that shows grey for excluded areas
                    const leftGrey = minPercent > 0 ? `#9ca3af 0%, #9ca3af ${minPercent}%` : '';
                    const transparent = `transparent ${minPercent}%, transparent ${maxPercent}%`;
                    const rightGrey = maxPercent < 100 ? `#9ca3af ${maxPercent}%, #9ca3af 100%` : '';
                    
                    const gradientParts = [leftGrey, transparent, rightGrey].filter(part => part !== '');
                    const backgroundGradient = `linear-gradient(to right, ${gradientParts.join(', ')})`;
                    
                    rangeHighlight.style.background = backgroundGradient;
                }
                
                // Position the highlight to cover the entire track
                rangeHighlight.style.left = '0%';
                rangeHighlight.style.width = '100%';
                
                console.log(`DEBUG - ${attributeType} range updated: ${minVal}-${maxVal} (${minText} to ${maxText}) - excluded areas will be grey`);
            }
            
            // Determine which slider should handle a click and update it directly
            function routeMouseEvent(event) {
                const rect = minSlider.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickPercent = Math.max(0, Math.min(1, clickX / rect.width));
                const clickValue = 1 + (clickPercent * 4);
                
                const minVal = parseInt(minSlider.value);
                const maxVal = parseInt(maxSlider.value);
                
                const distanceToMin = Math.abs(clickValue - minVal);
                const distanceToMax = Math.abs(clickValue - maxVal);
                
                // Determine which slider should be active
                let targetSlider;
                if (distanceToMin < distanceToMax) {
                    targetSlider = minSlider;
                } else if (distanceToMax < distanceToMin) {
                    targetSlider = maxSlider;
                } else {
                    // Equal distance - choose based on which side of range center we're on
                    const rangeCenter = (minVal + maxVal) / 2;
                    targetSlider = clickValue <= rangeCenter ? minSlider : maxSlider;
                }
                
                console.log(`DEBUG - Routing ${attributeType} event to ${targetSlider === minSlider ? 'min' : 'max'} slider`);
                
                // Directly set the value instead of dispatching events
                const targetValue = Math.round(clickValue);
                const clampedValue = Math.max(1, Math.min(5, targetValue));
                targetSlider.value = clampedValue;
                
                // Trigger the update manually
                updateRangeDisplay();
                
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Function to detect if clicking directly on a slider handle
            function isClickOnHandle(event, slider) {
                const rect = slider.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const sliderValue = parseInt(slider.value);
                const handlePercent = (sliderValue - 1) / 4; // Convert 1-5 to 0-1
                const handleX = rect.width * handlePercent;
                
                // Handle is considered "clicked" if click is within 15px of handle center
                return Math.abs(clickX - handleX) <= 15;
            }

            // Function to determine which handle is closer and manage z-index
            function updateHandlePriority(event) {
                const rect = minSlider.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mousePercent = Math.max(0, Math.min(1, mouseX / rect.width));
                const mouseValue = 1 + (mousePercent * 4);
                
                const minVal = parseInt(minSlider.value);
                const maxVal = parseInt(maxSlider.value);
                
                const distanceToMin = Math.abs(mouseValue - minVal);
                const distanceToMax = Math.abs(mouseValue - maxVal);
                
                // Always put the closer handle on top
                if (distanceToMin <= distanceToMax) {
                    minSlider.style.zIndex = '3';
                    maxSlider.style.zIndex = '2';
                    console.log(`DEBUG - Mouse closer to min handle for ${attributeType}`);
                } else {
                    minSlider.style.zIndex = '2';
                    maxSlider.style.zIndex = '3';
                    console.log(`DEBUG - Mouse closer to max handle for ${attributeType}`);
                }
            }

            // Add event routing to the container with dynamic handle priority
            const container = minSlider.parentElement;

            // Update handle priority on mouse movement
            container.addEventListener('mousemove', (event) => {
                updateHandlePriority(event);
            });

            // Handle mouse down with proper prioritization
            container.addEventListener('mousedown', (event) => {
                // Always update handle priority first
                updateHandlePriority(event);
                
                // Check if click is directly on either handle
                const onMinHandle = isClickOnHandle(event, minSlider);
                const onMaxHandle = isClickOnHandle(event, maxSlider);
                
                if (onMinHandle || onMaxHandle) {
                    // Direct handle click - let native dragging work
                    console.log(`DEBUG - Handle click detected, allowing native drag for ${attributeType}`);
                    // Don't prevent default - let browser handle the drag
                    return;
                } else {
                    // Track click - use our smart routing
                    console.log(`DEBUG - Track click detected, using routing for ${attributeType}`);
                    routeMouseEvent(event);
                    setTimeout(updateRangeDisplay, 20);
                }
            });

            // Add update listeners to both sliders
            minSlider.addEventListener('input', updateRangeDisplay);
            maxSlider.addEventListener('input', updateRangeDisplay);

            // Also listen for any value changes (backup mechanism)
            minSlider.addEventListener('change', updateRangeDisplay);
            maxSlider.addEventListener('change', updateRangeDisplay);

            // Add a mutation observer as final backup to catch any missed updates
            const observer = new MutationObserver(() => {
                updateRangeDisplay();
            });
            observer.observe(minSlider, { attributes: true, attributeFilter: ['value'] });
            observer.observe(maxSlider, { attributes: true, attributeFilter: ['value'] });

            // Initial update
            updateRangeDisplay();
            
            console.log(`DEBUG - ${attributeType} range slider with native behavior setup complete`);
        }


        // Initialize playlist tag selection
        function initializePlaylistTags() {
            console.log('DEBUG - Initializing playlist tag selection');
            
            if (!window.allTags || window.allTags.length === 0) {
                console.log('DEBUG - No tags available, loading them first');
                loadAvailableTags().then(() => {
                    populatePlaylistTags();
                });
            } else {
                populatePlaylistTags();
            }
        }

        function populatePlaylistTags() {
            const contextList = document.getElementById('playlist-context-list');
            const instrumentationList = document.getElementById('playlist-instrumentation-list');
            const genreSubList = document.getElementById('playlist-genre-sub-list');
            const genreList = document.getElementById('playlist-genre-list');
            const favouriteList = document.getElementById('playlist-favourite-list');
            
            if (!contextList || !instrumentationList || !genreSubList || !genreList || !favouriteList || !window.allTags) {
                console.log('DEBUG - Missing elements or tags for playlist tag population');
                return;
            }
            
            let contextHtml = '';
            let instrumentationHtml = '';
            let genreSubHtml = '';
            let genreHtml = '';
            let favouriteHtml = '';
            
            // Separate tags by all 5 categories
            window.allTags.forEach(tag => {
                const category = getTagCategory(tag.id);
                const tagHtml = `
                    <button onclick="togglePlaylistTag(${tag.id}, '${tag.name}')" 
                            id="playlist-tag-${tag.id}"
                            style="background-color: #e9ecef; color: #495057; border: 1px solid #ced4da; padding: 4px 8px; border-radius: 12px; font-size: 11px; margin: 2px; cursor: pointer; transition: all 0.2s;">
                        ${tag.name}
                    </button>
                `;
                
                if (category === 'context') {
                    contextHtml += tagHtml;
                } else if (category === 'instrumentation') {
                    instrumentationHtml += tagHtml;
                } else if (category === 'genre-sub') {
                    genreSubHtml += tagHtml;
                } else if (category === 'genre') {
                    genreHtml += tagHtml;
                } else if (category === 'favourite') {
                    favouriteHtml += tagHtml;
                }
            });
            
            // Update displays
            contextList.innerHTML = contextHtml || '<div style="color: #999; font-size: 11px; text-align: center; padding: 15px;">No context/vibe tags available</div>';
            instrumentationList.innerHTML = instrumentationHtml || '<div style="color: #999; font-size: 11px; text-align: center; padding: 15px;">No instrumentation tags available</div>';
            genreSubList.innerHTML = genreSubHtml || '<div style="color: #999; font-size: 11px; text-align: center; padding: 15px;">No genre sub tags available</div>';
            genreList.innerHTML = genreHtml || '<div style="color: #999; font-size: 11px; text-align: center; padding: 15px;">No genre tags available</div>';
            favouriteList.innerHTML = favouriteHtml || '<div style="color: #999; font-size: 11px; text-align: center; padding: 15px;">No favourite tags available</div>';
            
            console.log(`DEBUG - Populated playlist tags: ${contextHtml ? contextHtml.split('onclick').length - 1 : 0} context, ${instrumentationHtml ? instrumentationHtml.split('onclick').length - 1 : 0} instrumentation, ${genreSubHtml ? genreSubHtml.split('onclick').length - 1 : 0} genre-sub, ${genreHtml ? genreHtml.split('onclick').length - 1 : 0} genre, ${favouriteHtml ? favouriteHtml.split('onclick').length - 1 : 0} favourite`);
        }

        // Track selected tags for playlist creation
        let selectedPlaylistTags = []; // Will store {id: tagId, name: tagName, mode: 'include'|'exclude'}

        function togglePlaylistTag(tagId, tagName) {
            console.log(`DEBUG - Toggling playlist tag: ${tagName} (${tagId})`);
            
            const button = document.getElementById(`playlist-tag-${tagId}`);
            const existingIndex = selectedPlaylistTags.findIndex(tag => tag.id === tagId);
            
            if (existingIndex === -1) {
                // Add tag with current mode (from toggle state)
                const mode = isExcludeMode ? 'exclude' : 'include';
                selectedPlaylistTags.push({id: tagId, name: tagName, mode: mode});
                
                console.log(`DEBUG - Added tag ${tagName} with mode: ${mode}`);
                
                // Set button color based on mode
                if (mode === 'exclude') {
                    button.style.backgroundColor = '#dc3545';
                    button.style.color = 'white';
                    button.style.borderColor = '#dc3545';
                } else {
                    button.style.backgroundColor = '#1db954';
                    button.style.color = 'white';
                    button.style.borderColor = '#1db954';
                }
            } else {
                // Remove tag
                selectedPlaylistTags.splice(existingIndex, 1);
                button.style.backgroundColor = '#e9ecef';
                button.style.color = '#495057';
                button.style.borderColor = '#ced4da';
                
                console.log(`DEBUG - Removed tag ${tagName}`);
            }
            
            updateSelectedTagsDisplay();
            
            // Trigger dynamic filtering
            triggerDynamicFilter();
        }

        function updateSelectedTagsDisplay() {
            const container = document.getElementById('selected-tags-container');
            
            if (!container) return;
            
            if (selectedPlaylistTags.length === 0) {
                container.innerHTML = '<span style="color: #999; font-size: 11px; font-style: italic;">No tags selected</span>';
            } else {
                let tagsHtml = '';
                selectedPlaylistTags.forEach(tag => {
                    const backgroundColor = tag.mode === 'exclude' ? '#dc3545' : '#1db954';
                    const textLabel = tag.mode === 'exclude' ? 'Exclude' : 'Include';
                    
                    tagsHtml += `
                        <span style="display: inline-flex; align-items: center; background-color: ${backgroundColor}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 10px; margin: 2px; font-weight: 500;" title="${textLabel}: ${tag.name}">
                            ${tag.name}
                            <button onclick="removeSelectedPlaylistTag(${tag.id})" 
                                    style="background: none; border: none; color: white; cursor: pointer; font-size: 12px; padding: 0; margin-left: 3px;">×</button>
                        </span>
                    `;
                });
                container.innerHTML = tagsHtml;
            }
            
            console.log(`DEBUG - Updated selected tags display: ${selectedPlaylistTags.length} tags (${selectedPlaylistTags.filter(t => t.mode === 'include').length} include, ${selectedPlaylistTags.filter(t => t.mode === 'exclude').length} exclude)`);
        }

        function removeSelectedPlaylistTag(tagId) {
            console.log(`DEBUG - Removing selected playlist tag: ${tagId}`);
            
            // Find and deselect the button
            const button = document.getElementById(`playlist-tag-${tagId}`);
            if (button) {
                button.style.backgroundColor = '#e9ecef';
                button.style.color = '#495057';
                button.style.borderColor = '#ced4da';
            }
            
            // Remove from selected tags
            selectedPlaylistTags = selectedPlaylistTags.filter(tag => tag.id !== tagId);
            updateSelectedTagsDisplay();
            
            // Trigger dynamic filtering to refresh results
            triggerDynamicFilter();
        }

        // Apply attribute and tag filters to find matching songs
        function applyAttributeFilters() {
            console.log('DEBUG - Applying filters to find songs');
            
            // Get attribute ranges
            const tempoMin = parseInt(document.getElementById('tempo-min').value);
            const tempoMax = parseInt(document.getElementById('tempo-max').value);
            const energyMin = parseInt(document.getElementById('energy-min').value);
            const energyMax = parseInt(document.getElementById('energy-max').value);
            const moodMin = parseInt(document.getElementById('mood-min').value);
            const moodMax = parseInt(document.getElementById('mood-max').value);
            
            // Get selected tag IDs
            const tagIds = selectedPlaylistTags.map(tag => tag.id);
            
            console.log(`DEBUG - Filter criteria: Tempo ${tempoMin}-${tempoMax}, Energy ${energyMin}-${energyMax}, Mood ${moodMin}-${moodMax}, Tags: [${tagIds.join(', ')}]`);
            
            // Show loading state
            const resultsSection = document.getElementById('playlist-results-section');
            const resultsCount = document.getElementById('results-count');
            const songsContainer = document.getElementById('filtered-songs-container');
            const applyBtn = document.getElementById('apply-filters-btn');
            
            applyBtn.textContent = 'Searching...';
            applyBtn.disabled = true;
            
            resultsSection.style.display = 'block';
            resultsCount.textContent = '...';
            songsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Filtering your liked songs...</div>';
            
            // Send filter request to backend
            const params = new URLSearchParams({
                tempo_min: tempoMin,
                tempo_max: tempoMax,
                energy_min: energyMin,
                energy_max: energyMax,
                mood_min: moodMin,
                mood_max: moodMax,
                tag_ids: tagIds.join(',')
            });
            
            fetch(`/filter-liked-songs?${params}`)
                .then(response => response.json())
                .then(data => {
                    console.log(`DEBUG - Filter results: ${data.songs.length} songs found`);
                    displayFilteredSongs(data.songs);
                    
                    // Reset button
                    applyBtn.textContent = 'Find Songs';
                    applyBtn.disabled = false;
                })
                .catch(error => {
                    console.error('Error filtering songs:', error);
                    songsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545;">Error occurred while filtering songs. Please try again.</div>';
                    
                    // Reset button
                    applyBtn.textContent = 'Find Songs';
                    applyBtn.disabled = false;
                });
        }

        // Dynamic filtering with debouncing
        let filterTimeout = null;
        let isFilteringInProgress = false;

        function triggerDynamicFilter() {
            // Clear any existing timeout
            if (filterTimeout) {
                clearTimeout(filterTimeout);
            }
            
            // Don't start new filter if one is already in progress
            if (isFilteringInProgress) {
                console.log('DEBUG - Filter already in progress, debouncing...');
                filterTimeout = setTimeout(triggerDynamicFilter, 300);
                return;
            }
            
            // Set a timeout to avoid too many rapid API calls
            filterTimeout = setTimeout(() => {
                console.log('DEBUG - Triggering dynamic filter update');
                applyAttributeFiltersWithLoading();
            }, 300); // 300ms delay
        }

        function applyAttributeFiltersWithLoading() {
            if (isFilteringInProgress) {
                console.log('DEBUG - Filter already in progress, skipping');
                return;
            }
            
            console.log('DEBUG - Starting dynamic filter with loading state');
            isFilteringInProgress = true;
            
            // Show loading state
            const resultsSection = document.getElementById('playlist-results-section');
            const resultsCount = document.getElementById('results-count');
            const songsContainer = document.getElementById('filtered-songs-container');
            
            resultsSection.style.display = 'block';
            resultsCount.textContent = '...';
            
            // Check if cache is loaded
            if (!isCacheLoaded) {
                console.log('DEBUG - Cache not loaded yet, showing loading message and waiting');
                songsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #666; font-size: 12px;"><em>Loading your liked songs cache...</em><br><small>This may take a moment on first load</small></div>';
                
                // Wait for cache to load, then retry
                if (cacheLoadPromise) {
                    cacheLoadPromise.then(() => {
                        console.log('DEBUG - Cache loaded, retrying filter');
                        isFilteringInProgress = false;
                        applyAttributeFiltersWithLoading();
                    }).catch(error => {
                        console.error('Cache loading failed:', error);
                        songsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545; font-size: 12px;">Failed to load your liked songs cache. Please try refreshing the page.</div>';
                        isFilteringInProgress = false;
                    });
                } else {
                    // Try to start cache loading
                    loadLikedSongsCache().then(() => {
                        console.log('DEBUG - Cache loaded, retrying filter');
                        isFilteringInProgress = false;
                        applyAttributeFiltersWithLoading();
                    }).catch(error => {
                        console.error('Cache loading failed:', error);
                        songsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545; font-size: 12px;">Failed to load your liked songs cache. Please try refreshing the page.</div>';
                        isFilteringInProgress = false;
                    });
                }
                return;
            }
            
            // Cache is loaded, proceed with normal filtering
            songsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #666; font-size: 12px;"><em>Filtering your songs...</em></div>';
            
            // Get attribute ranges
            const tempoMin = parseInt(document.getElementById('tempo-min').value);
            const tempoMax = parseInt(document.getElementById('tempo-max').value);
            const energyMin = parseInt(document.getElementById('energy-min').value);
            const energyMax = parseInt(document.getElementById('energy-max').value);
            const emotionMin = parseInt(document.getElementById('emotion-min').value);
            const emotionMax = parseInt(document.getElementById('emotion-max').value);

            // Separate include and exclude tag IDs
            const includeTags = selectedPlaylistTags.filter(tag => tag.mode === 'include').map(tag => tag.id);
            const excludeTags = selectedPlaylistTags.filter(tag => tag.mode === 'exclude').map(tag => tag.id);

            console.log(`DEBUG - Dynamic filter criteria: Tempo ${tempoMin}-${tempoMax}, Energy ${energyMin}-${energyMax}, Emotion ${emotionMin}-${emotionMax}, Include tags: [${includeTags.join(', ')}], Exclude tags: [${excludeTags.join(', ')}]`);

            // Send filter request to backend
            const params = new URLSearchParams({
                tempo_min: tempoMin,
                tempo_max: tempoMax,
                energy_min: energyMin,
                energy_max: energyMax,
                mood_min: emotionMin,
                mood_max: emotionMax,
                include_tag_ids: includeTags.join(','),
                exclude_tag_ids: excludeTags.join(',')
            });
            
            fetch(`/filter-liked-songs?${params}`)
                .then(response => response.json())
                .then(data => {
                    console.log(`DEBUG - Dynamic filter results: ${data.songs.length} songs found`);
                    displayFilteredSongs(data.songs);
                })
                .catch(error => {
                    console.error('Error in dynamic filtering:', error);
                    songsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545; font-size: 12px;">Error occurred while filtering. Please try refreshing the page.</div>';
                })
                .finally(() => {
                    isFilteringInProgress = false;
                    console.log('DEBUG - Dynamic filter completed');
                });
        }

        // Setup dynamic filtering event listeners
        function setupDynamicFiltering() {
            console.log('DEBUG - Setting up dynamic filtering event listeners');
            
            // Add listeners to range sliders
            const sliders = ['tempo-min', 'tempo-max', 'energy-min', 'energy-max', 'emotion-min', 'emotion-max'];
            sliders.forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                if (slider) {
                    slider.addEventListener('input', triggerDynamicFilter);
                    console.log(`DEBUG - Added event listener to ${sliderId}`);
                }
            });
            
            // Tag selection changes are handled by modifying the existing togglePlaylistTag function
            console.log('DEBUG - Dynamic filtering setup complete');
        }

        // Display the filtered songs results with Spotify previews
        function displayFilteredSongs(songs) {
            const resultsCount = document.getElementById('results-count');
            const songsContainer = document.getElementById('filtered-songs-container');
            
            console.log(`DEBUG - Attempting to display ${songs.length} filtered songs`);
            
            resultsCount.textContent = songs.length;
            
            if (songs.length === 0) {
                songsContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: #666;">No songs match your criteria. Try adjusting the ranges or adding some tags to narrow your search.</div>';
                return;
            }
            
            // Limit display to first 50 songs for performance
            const songsToDisplay = songs.slice(0, 50);
            const isLimited = songs.length > 50;
            
            console.log(`DEBUG - Displaying first ${songsToDisplay.length} of ${songs.length} songs`);
            
            let songsHtml = '';
            songsToDisplay.forEach((song, index) => {
                // Build tags display - more compact
                let tagsHtml = '';
                if (song.tags && song.tags.length > 0) {
                    song.tags.forEach(tag => {
                        tagsHtml += `<span style="background-color: #e9ecef; color: #495057; padding: 1px 5px; border-radius: 8px; font-size: 9px; margin: 1px 2px 1px 0; display: inline-block;">${tag.name}</span>`;
                    });
                } else {
                    tagsHtml = '<span style="color: #999; font-size: 9px; font-style: italic;">No tags</span>';
                }
                
                // Build attributes display
                const tempoText = getAttributeLabel(song.tempo || 3, 'tempo').replace('(', '').replace(')', '');
                const energyText = getAttributeLabel(song.energy || 3, 'energy').replace('(', '').replace(')', '');
                const moodText = getAttributeLabel(song.mood || 3, 'mood').replace('(', '').replace(')', '');
                
                songsHtml += `
                    <div style="padding: 10px; border-bottom: 1px solid #e9ecef; ${index % 2 === 0 ? 'background-color: #f8f9fa;' : 'background-color: white;'}">
                        
                        <!-- Spotify Preview -->
                        <div style="margin-bottom: 8px;">
                            <iframe src="https://open.spotify.com/embed/track/${song.spotify_id}?utm_source=generator&theme=0" 
                                    width="100%" 
                                    height="80" 
                                    frameBorder="0" 
                                    allowfullscreen="" 
                                    allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
                                    loading="lazy"
                                    style="border-radius: 8px;">
                            </iframe>
                        </div>
                        
                        <!-- Tags and Attributes row -->
                        <div style="display: flex; justify-content: space-between; align-items: flex-end; min-height: 16px;">
                            <!-- Tags on the left -->
                            <div style="flex: 1;">
                                <div style="font-size: 9px; color: #666; margin-bottom: 2px;">Tags:</div>
                                <div style="line-height: 1.2;">${tagsHtml}</div>
                            </div>
                            
                            <!-- Attributes on the bottom right -->
                            <div style="text-align: right; font-size: 9px; color: #888; margin-left: 8px;">
                                <div style="background-color: white; padding: 2px 6px; border-radius: 10px; border: 1px solid #dee2e6;">
                                    T: ${tempoText} | E: ${energyText} | M: ${moodText}
                                </div>
                            </div>
                        </div>
                        
                    </div>
                `;
            });
            
            // Add limitation notice if results were truncated
            if (isLimited) {
                songsHtml += `
                    <div style="padding: 15px; text-align: center; background-color: #f8f9fa; color: #666; font-style: italic; border-top: 2px solid #dee2e6;">
                        Can't display more than 50 songs
                    </div>
                `;
            }
            
            songsContainer.innerHTML = songsHtml;
            console.log(`DEBUG - Successfully displayed ${songsToDisplay.length} filtered songs with previews`);
        }

        // Show playlist selection modal before importing
        function importAllSongsToLiked() {
            console.log('DEBUG - Opening playlist selection modal');
            
            // Show the modal
            const modal = document.getElementById('playlist-import-modal');
            modal.style.display = 'block';
            
            // Load playlists into the modal
            loadPlaylistsForImport();
        }

        // Load playlists into the import modal
        function loadPlaylistsForImport() {
            console.log('DEBUG - Loading playlists for import modal');
            
            const playlistsContainer = document.getElementById('playlists-for-import');
            playlistsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Loading your playlists...</div>';
            
            // Get playlists from the existing playlists data or fetch fresh
            if (window.userPlaylists && window.userPlaylists.length > 0) {
                populatePlaylistsForImport(window.userPlaylists);
            } else {
                // Fetch playlists
                fetch('/get-user-playlists')
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            window.userPlaylists = data.playlists;
                            populatePlaylistsForImport(data.playlists);
                        } else {
                            playlistsContainer.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 20px;">Failed to load playlists</div>';
                        }
                    })
                    .catch(error => {
                        console.error('Error loading playlists:', error);
                        playlistsContainer.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 20px;">Error loading playlists</div>';
                    });
            }
        }

        // Populate the playlists in the import modal
        function populatePlaylistsForImport(playlists) {
            const playlistsContainer = document.getElementById('playlists-for-import');
            
            if (!playlists || playlists.length === 0) {
                playlistsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No playlists found</div>';
                return;
            }
            
            let playlistsHtml = '';
            playlists.forEach(playlist => {
                // Check if this playlist should be unchecked by default
                const isCheckedByDefault = playlist.name !== 'My Shazam Tracks';
                
                playlistsHtml += `
                    <label style="display: flex; align-items: center; padding: 8px; margin: 2px 0; cursor: pointer; border-radius: 5px;" 
                        onmouseover="this.style.backgroundColor='#f8f9fa'" 
                        onmouseout="this.style.backgroundColor='transparent'">
                        <input type="checkbox" class="playlist-checkbox" value="${playlist.id}" ${isCheckedByDefault ? 'checked' : ''} 
                            style="margin-right: 10px; cursor: pointer;" onchange="updateSelectedPlaylistsCount()">
                        <div style="flex: 1;">
                            <div style="font-weight: 500; font-size: 13px; color: #333;">${playlist.name}</div>
                            <div style="font-size: 11px; color: #666;">${playlist.track_count} songs</div>
                        </div>
                    </label>
                `;
            });
            
            playlistsContainer.innerHTML = playlistsHtml;
            
            // Set up select all functionality
            const selectAllCheckbox = document.getElementById('select-all-playlists');
            selectAllCheckbox.addEventListener('change', function() {
                const checkboxes = document.querySelectorAll('.playlist-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = this.checked;
                });
                updateSelectedPlaylistsCount();
            });
            
            // Initial count
            updateSelectedPlaylistsCount();
        }

        // Update the selected playlists count
        function updateSelectedPlaylistsCount() {
            const checkboxes = document.querySelectorAll('.playlist-checkbox');
            const selectedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
            const totalCount = checkboxes.length;
            
            document.getElementById('selected-playlists-count').textContent = 
                `${selectedCount} of ${totalCount} playlists selected`;
                
            // Update select all checkbox state
            const selectAllCheckbox = document.getElementById('select-all-playlists');
            if (selectedCount === 0) {
                selectAllCheckbox.indeterminate = false;
                selectAllCheckbox.checked = false;
            } else if (selectedCount === totalCount) {
                selectAllCheckbox.indeterminate = false;
                selectAllCheckbox.checked = true;
            } else {
                selectAllCheckbox.indeterminate = true;
            }
        }

        // Close the playlist import modal
        function closePlaylistImportModal() {
            const modal = document.getElementById('playlist-import-modal');
            modal.style.display = 'none';
        }

        // Confirm import with selected playlists
        function confirmImportSelectedPlaylists() {
            const selectedPlaylists = Array.from(document.querySelectorAll('.playlist-checkbox:checked'))
                .map(cb => cb.value);
            
            if (selectedPlaylists.length === 0) {
                alert('Please select at least one playlist to import.');
                return;
            }
            
            console.log(`DEBUG - Importing from ${selectedPlaylists.length} selected playlists`);
            
            // Close the modal
            closePlaylistImportModal();
            
            // Start the actual import process
            performImportFromSelectedPlaylists(selectedPlaylists);
        }


        // Perform import from selected playlists with progressive loading
        function performImportFromSelectedPlaylists(playlistIds) {
            const button = document.getElementById('import-all-songs-btn');
            const progressDiv = document.getElementById('import-progress');
            const statusSpan = document.getElementById('import-status');
            const detailsSpan = document.getElementById('import-details');
            const progressBar = document.getElementById('import-progress-bar');
            
            // Show progress and disable button
            button.disabled = true;
            button.textContent = 'Importing...';
            progressDiv.style.display = 'block';
            statusSpan.textContent = 'Getting playlist count...';
            detailsSpan.textContent = 'Preparing import process...';
            progressBar.style.width = '0%';
            
            // First, get the total number of playlists for progress calculation
            fetch('/get-playlist-count')
                .then(response => response.json())
                .then(countData => {
                    if (!countData.success) {
                        throw new Error(countData.error || 'Failed to get playlist count');
                    }
                    
                    console.log(`DEBUG - Total playlists: ${countData.total_playlists}`);
                    statusSpan.textContent = `Found ${countData.total_playlists} playlists. Starting import...`;
                    
                    // Start the batch processing
                    processBatchImport(playlistIds, 0, 5, countData.total_playlists, {
                        totalSongsAdded: 0,
                        totalUniqueTracksFound: 0,
                        playlistsProcessed: []
                    });
                })
                .catch(error => {
                    console.error('Error getting playlist count:', error);
                    statusSpan.textContent = 'Failed to get playlist count';
                    detailsSpan.textContent = `Error: ${error.message}`;
                    
                    // Re-enable button
                    button.disabled = false;
                    button.textContent = 'Import All Songs To Liked Songs';
                });
        }

        // Process batches of playlists progressively
        function processBatchImport(playlistIds, batchStart, batchSize, totalPlaylists, accumulatedResults) {
            const statusSpan = document.getElementById('import-status');
            const detailsSpan = document.getElementById('import-details');
            const progressBar = document.getElementById('import-progress-bar');
            
            if (batchStart >= playlistIds.length) {
                // All batches completed
                finalizeBatchImport(accumulatedResults, totalPlaylists);
                return;
            }
            
            const batchEnd = Math.min(batchStart + batchSize, playlistIds.length);
            const currentBatch = playlistIds.slice(batchStart, batchEnd);
            
            statusSpan.textContent = `Processing playlists ${batchStart + 1}-${batchEnd} of ${playlistIds.length}...`;
            
            fetch('/import-playlists-batch', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    playlist_ids: playlistIds,
                    batch_start: batchStart,
                    batch_size: batchSize
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update progress bar
                    const progressPercent = (batchEnd / playlistIds.length) * 100;
                    progressBar.style.width = `${progressPercent}%`;
                    
                    // Update accumulated results
                    accumulatedResults.totalSongsAdded += data.batch_songs_added;
                    accumulatedResults.totalUniqueTracksFound += data.batch_unique_tracks;
                    accumulatedResults.totalAlreadyLiked = (accumulatedResults.totalAlreadyLiked || 0) + data.batch_songs_already_liked;
                    accumulatedResults.playlistsProcessed = accumulatedResults.playlistsProcessed.concat(data.playlists_processed);
                    
                    // Store existing liked count from first batch
                    if (batchStart === 0 && data.existing_liked_count) {
                        accumulatedResults.existingLikedCount = data.existing_liked_count;
                    }
                    
                    // Update status with accurate information
                    detailsSpan.innerHTML = `
                        Processed: ${accumulatedResults.playlistsProcessed.length} playlists<br>
                        Found: ${accumulatedResults.totalUniqueTracksFound} unique tracks in playlists<br>
                        Already in Liked Songs: ${accumulatedResults.totalAlreadyLiked || 0}<br>
                        <strong>New songs added: ${accumulatedResults.totalSongsAdded}</strong>
                    `;
                    
                    console.log(`DEBUG - Batch ${batchStart}-${batchEnd-1} complete: +${data.batch_songs_added} new songs (${data.batch_songs_already_liked} already liked)`);
                    
                    // Process next batch
                    setTimeout(() => {
                        processBatchImport(playlistIds, batchEnd, batchSize, totalPlaylists, accumulatedResults);
                    }, 100); // Small delay to show progress update
                    
                } else {
                    throw new Error(data.error || 'Batch import failed');
                }
            })
            .catch(error => {
                console.error('Batch import error:', error);
                statusSpan.textContent = 'Import failed during batch processing';
                detailsSpan.textContent = `Error: ${error.message}`;
                
                // Re-enable button
                const button = document.getElementById('import-all-songs-btn');
                button.disabled = false;
                button.textContent = 'Import All Songs To Liked Songs';
            });
        }

        // Finalize the batch import process
        function finalizeBatchImport(results, totalPlaylists) {
            const button = document.getElementById('import-all-songs-btn');
            const progressDiv = document.getElementById('import-progress');
            const statusSpan = document.getElementById('import-status');
            const detailsSpan = document.getElementById('import-details');
            const progressBar = document.getElementById('import-progress-bar');
            
            // Update to completion state
            progressBar.style.width = '100%';
            statusSpan.textContent = 'Import completed successfully!';
            detailsSpan.innerHTML = `
                <strong>Import Summary:</strong><br>
                Processed ${results.playlistsProcessed.length} playlists<br>
                Found ${results.totalUniqueTracksFound} unique songs total<br>
                <strong>Added ${results.totalSongsAdded} new songs to Liked Songs</strong>
            `;
            
            // If songs were added, refresh the liked songs cache
            if (results.totalSongsAdded > 0) {
                statusSpan.textContent = 'Refreshing liked songs cache...';
                detailsSpan.innerHTML += '<br><em>Updating search cache with new songs...</em>';
                
                // Trigger cache reload
                loadLikedSongsCache().then(() => {
                    statusSpan.textContent = 'Import and cache refresh completed!';
                    detailsSpan.innerHTML = `
                        <strong>Import Summary:</strong><br>
                        Processed ${results.playlistsProcessed.length} playlists<br>
                        Found ${results.totalUniqueTracksFound} unique songs total<br>
                        <strong>Added ${results.totalSongsAdded} new songs to Liked Songs</strong><br>
                        <em>✓ Search cache updated with all songs</em>
                    `;
                }).catch((error) => {
                    console.error('Cache refresh failed:', error);
                    statusSpan.textContent = 'Import completed, cache refresh failed';
                    detailsSpan.innerHTML += '<br><em>Note: You may need to refresh the page to search new songs</em>';
                });
            }
            
            // Hide progress after 8 seconds
            setTimeout(() => {
                progressDiv.style.display = 'none';
            }, 8000);
            
            // Re-enable button
            button.disabled = false;
            button.textContent = 'Import All Songs To Liked Songs';
            
            console.log(`DEBUG - Import completed: ${results.totalSongsAdded} songs added total`);
        }

        // Enhanced debug function to find the exact issue
        function debugTagSync() {
            console.log('=== DETAILED TAG SYNC DEBUG ===');
            
            // Check backend first
            fetch('/get-recent-tags')
                .then(response => response.json())
                .then(data => {
                    console.log('1. BACKEND TAGS:', data.tags.map(t => `${t.name} (id: ${t.id})`));
                    
                    // Update frontend cache
                    window.allTags = data.tags;
                    console.log('2. FRONTEND CACHE UPDATED');
                    
                    // Debug each tag's category assignment
                    console.log('3. CATEGORY ASSIGNMENTS:');
                    data.tags.forEach(tag => {
                        const category = getTagCategory(tag.id);
                        console.log(`   ${tag.name} (id: ${tag.id}) -> category: "${category}"`);
                    });
                    
                    // Debug localStorage categories
                    console.log('4. LOCALSTORAGE CATEGORIES:', localStorage.getItem('tagCategories'));
                    
                    // Test the filtering logic step by step
                    console.log('5. FILTERING LOGIC TEST:');
                    const testContainer = document.querySelector('.available-tags-container');
                    if (testContainer) {
                        const currentTags = getCurrentTagsForSong(testContainer);
                        console.log('   Current tags for song:', currentTags);
                        
                        const inactiveTags = data.tags.filter(tag => !currentTags.includes(tag.id.toString()));
                        console.log('   Inactive tags:', inactiveTags.map(t => `${t.name} (id: ${t.id})`));
                        
                        // Test category separation
                        const contextTags = [];
                        const instrumentationTags = [];
                        const genreSubTags = [];
                        const genreTags = [];
                        
                        inactiveTags.forEach(tag => {
                            const category = getTagCategory(tag.id);
                            console.log(`   Processing ${tag.name}: category = "${category}"`);
                            
                            if (category === 'context') {
                                contextTags.push(tag);
                            } else if (category === 'instrumentation') {
                                instrumentationTags.push(tag);
                            } else if (category === 'genre-sub') {
                                genreSubTags.push(tag);
                            } else if (category === 'genre') {
                                genreTags.push(tag);
                            } else {
                                console.log(`   ❌ UNRECOGNIZED CATEGORY: "${category}" for tag ${tag.name}`);
                            }
                        });
                        
                        console.log('   Final categorization:');
                        console.log('     Context:', contextTags.map(t => t.name));
                        console.log('     Instrumentation:', instrumentationTags.map(t => t.name));
                        console.log('     Genre-sub:', genreSubTags.map(t => t.name));
                        console.log('     Genre:', genreTags.map(t => t.name));
                    }
                    
                    // Force refresh the display
                    console.log('6. FORCING DISPLAY REFRESH...');
                    const containers = document.querySelectorAll('.available-tags-container');
                    containers.forEach((container, index) => {
                        console.log(`   Refreshing container ${index + 1}`);
                        displayAvailableTags(container, data.tags);
                    });
                    
                })
                .catch(error => {
                    console.error('ERROR in debug:', error);
                });
        }

        // Tag ordering within categories
        function getTagOrdering() {
            try {
                const stored = localStorage.getItem('tagOrdering');
                return stored ? JSON.parse(stored) : {};
            } catch (e) {
                console.log('DEBUG - Error reading tag ordering, clearing:', e);
                localStorage.removeItem('tagOrdering');
                return {};
            }
        }

        function setTagOrdering(category, orderedTagIds) {
            const ordering = getTagOrdering();
            ordering[category] = orderedTagIds;
            localStorage.setItem('tagOrdering', JSON.stringify(ordering));
            console.log(`DEBUG - Saved ordering for ${category}:`, orderedTagIds);
        }

        function sortTagsByOrder(tags, category) {
            const ordering = getTagOrdering();
            const categoryOrder = ordering[category];
            
            if (!categoryOrder) {
                // No custom order, use default (alphabetical)
                return tags.sort((a, b) => a.name.localeCompare(b.name));
            }
            
            // Sort by custom order, with unordered tags at the end
            return tags.sort((a, b) => {
                const aIndex = categoryOrder.indexOf(a.id);
                const bIndex = categoryOrder.indexOf(b.id);
                
                // Both have custom positions
                if (aIndex !== -1 && bIndex !== -1) {
                    return aIndex - bIndex;
                }
                
                // A has position, B doesn't - A comes first
                if (aIndex !== -1 && bIndex === -1) {
                    return -1;
                }
                
                // B has position, A doesn't - B comes first
                if (aIndex === -1 && bIndex !== -1) {
                    return 1;
                }
                
                // Neither has position - alphabetical
                return a.name.localeCompare(b.name);
            });
        }

        // Updated tag selection with per-tag include/exclude mode
        let isExcludeMode = false; // This now only affects NEW selections

        function toggleExcludeMode() {
            const toggle = document.getElementById('exclude-mode-toggle');
            isExcludeMode = toggle.checked;
            
            console.log(`DEBUG - Exclude mode for NEW selections: ${isExcludeMode}`);
            
            // Update toggle visual state
            updateExcludeToggleVisual();
            
            // Note: We don't update existing tags or trigger filtering here
            // The toggle only affects future tag selections
        }

        function updateExcludeToggleVisual() {
            const slider = document.querySelector('.exclude-toggle-slider');
            const circle = document.querySelector('.exclude-toggle-circle');
            
            if (slider && circle) {
                if (isExcludeMode) {
                    slider.style.backgroundColor = '#dc3545';
                    circle.style.left = '22px';
                } else {
                    slider.style.backgroundColor = '#ccc';
                    circle.style.left = '2px';
                }
            }
        }

        function updateSelectedTagColors() {
            // Update all selected tag button colors based on exclude mode
            selectedPlaylistTags.forEach(tag => {
                const button = document.getElementById(`playlist-tag-${tag.id}`);
                if (button) {
                    if (isExcludeMode) {
                        // Red colors for exclude mode
                        button.style.backgroundColor = '#dc3545';
                        button.style.color = 'white';
                        button.style.borderColor = '#dc3545';
                    } else {
                        // Green colors for include mode
                        button.style.backgroundColor = '#1db954';
                        button.style.color = 'white';
                        button.style.borderColor = '#1db954';
                    }
                }
            });
        }

        // Create playlist from filtered results
        function createPlaylistFromFiltered() {
            console.log('DEBUG - createPlaylistFromFiltered called');
            
            const playlistNameInput = document.getElementById('new-playlist-name');
            const playlistName = playlistNameInput.value.trim();
            
            if (!playlistName) {
                alert('Please enter a playlist name.');
                playlistNameInput.focus();
                return;
            }
            
            console.log('DEBUG - Creating playlist:', playlistName);
            
            // Generate description with error handling
            let description;
            try {
                description = generatePlaylistDescription();
                console.log('DEBUG - Generated description successfully');
            } catch (error) {
                console.error('ERROR - Failed to generate description:', error);
                description = 'Songs filtered by attributes and tags';
            }
            
            // Get current filter criteria to re-run the search and get song IDs
            const tempoMin = parseInt(document.getElementById('tempo-min').value);
            const tempoMax = parseInt(document.getElementById('tempo-max').value);
            const energyMin = parseInt(document.getElementById('energy-min').value);
            const energyMax = parseInt(document.getElementById('energy-max').value);
            const emotionMin = parseInt(document.getElementById('emotion-min').value);
            const emotionMax = parseInt(document.getElementById('emotion-max').value);
            
            const includeTags = selectedPlaylistTags.filter(tag => tag.mode === 'include').map(tag => tag.id);
            const excludeTags = selectedPlaylistTags.filter(tag => tag.mode === 'exclude').map(tag => tag.id);
            
            // Show loading state
            const createButton = event.target;
            const originalText = createButton.textContent;
            createButton.textContent = 'Creating...';
            createButton.disabled = true;
            
            console.log('DEBUG - Sending playlist creation request with:', {
                playlist_name: playlistName,
                description: description,
                tempo_min: tempoMin,
                tempo_max: tempoMax,
                energy_min: energyMin,
                energy_max: energyMax,
                mood_min: emotionMin,
                mood_max: emotionMax,
                include_tag_ids: includeTags,
                exclude_tag_ids: excludeTags
            });
            
            // Send request to backend
            fetch('/create-filtered-playlist', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    playlist_name: playlistName,
                    description: description,
                    tempo_min: tempoMin,
                    tempo_max: tempoMax,
                    energy_min: energyMin,
                    energy_max: energyMax,
                    mood_min: emotionMin,
                    mood_max: emotionMax,
                    include_tag_ids: includeTags,
                    exclude_tag_ids: excludeTags
                })
            })
            .then(response => {
                console.log('DEBUG - Received response:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('DEBUG - Response data:', data);
                if (data.success) {
                    alert(`Successfully created playlist "${playlistName}" with ${data.songs_added} songs!`);
                    playlistNameInput.value = ''; // Clear the input
                    
                    // Refresh the playlists section to show the new playlist
                    refreshPlaylistsSection();
                } else {
                    alert(`Failed to create playlist: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error creating playlist:', error);
                alert('An error occurred while creating the playlist.');
            })
            .finally(() => {
                // Reset button
                createButton.textContent = originalText;
                createButton.disabled = false;
            });
        }

        // Generate smart playlist description with embedded criteria for later parsing
        function generatePlaylistDescription() {
            try {
                console.log('DEBUG - Starting generatePlaylistDescription');
                
                const tempoMin = parseInt(document.getElementById('tempo-min').value);
                const tempoMax = parseInt(document.getElementById('tempo-max').value);
                const energyMin = parseInt(document.getElementById('energy-min').value);
                const energyMax = parseInt(document.getElementById('energy-max').value);
                const emotionMin = parseInt(document.getElementById('emotion-min').value);
                const emotionMax = parseInt(document.getElementById('emotion-max').value);
                
                const includeTags = selectedPlaylistTags.filter(tag => tag.mode === 'include');
                const excludeTags = selectedPlaylistTags.filter(tag => tag.mode === 'exclude');
                
                // Build human-readable description
                let parts = [];
                
                // Add tempo range
                const tempoText = getRangeText(tempoMin, tempoMax, 'tempo');
                if (tempoText !== 'any') {
                    parts.push(`${tempoText} tempo`);
                }
                
                // Add energy range
                const energyText = getRangeText(energyMin, energyMax, 'energy');
                if (energyText !== 'any') {
                    parts.push(`${energyText} energy`);
                }
                
                // Add emotion range
                const emotionText = getRangeText(emotionMin, emotionMax, 'emotion');
                if (emotionText !== 'any') {
                    parts.push(`${emotionText} emotion`);
                }
                
                // Add included tags
                if (includeTags.length > 0) {
                    const tagNames = includeTags.map(tag => tag.name).join(', ');
                    parts.push(tagNames);
                }
                
                // Add excluded tags
                if (excludeTags.length > 0) {
                    const tagNames = excludeTags.map(tag => tag.name).join(', ');
                    parts.push(`not including ${tagNames}`);
                }
                
                // Create human-readable description
                let humanDescription;
                if (parts.length === 0) {
                    humanDescription = 'All songs from your liked songs';
                } else if (parts.length === 1) {
                    humanDescription = parts[0];
                } else if (parts.length === 2) {
                    humanDescription = parts.join(' and ');
                } else {
                    const lastPart = parts.pop();
                    humanDescription = parts.join(', ') + ' and ' + lastPart;
                }
                
                // Create compact machine-readable criteria (much shorter)
                const criteria = {
                    t: [tempoMin, tempoMax],
                    e: [energyMin, energyMax],
                    m: [emotionMin, emotionMax],
                    i: includeTags.map(tag => tag.id),
                    x: excludeTags.map(tag => tag.id),
                    v: 1
                };
                
                // Create a much shorter embedded string
                const criteriaString = JSON.stringify(criteria);
                const encodedCriteria = btoa(criteriaString);
                
                // Keep description under 300 characters to be safe
                const shortDescription = humanDescription.length > 200 ? 
                    humanDescription.substring(0, 200) + '...' : humanDescription;
                
                // Use a simpler marker format
                const fullDescription = `${shortDescription} [ST:${encodedCriteria}]`;
                
                console.log('DEBUG - Full description:', fullDescription);
                console.log('DEBUG - Description length:', fullDescription.length);
                
                // If still too long, use just the human description for now
                if (fullDescription.length > 300) {
                    console.log('DEBUG - Description too long, using simple version');
                    return shortDescription;
                }
                
                return fullDescription;
                
            } catch (error) {
                console.error('ERROR - generatePlaylistDescription failed:', error);
                return 'Songs filtered by attributes and tags';
            }
        }

        // Helper function to convert ranges to text
        function getRangeText(min, max, attributeType) {
            // If full range (1-5), return 'any'
            if (min === 1 && max === 5) {
                return 'any';
            }
            
            // Get labels without parentheses
            const minLabel = getAttributeLabel(min, attributeType).replace(/[()]/g, '').toLowerCase();
            const maxLabel = getAttributeLabel(max, attributeType).replace(/[()]/g, '').toLowerCase();
            
            // If same value, return single label
            if (min === max) {
                return minLabel;
            }
            
            // Return range
            return `${minLabel} to ${maxLabel}`;
        }
        // Parse playlist description to extract filter criteria
        function parsePlaylistCriteria(description) {
            if (!description) return null;
            
            // Look for the embedded criteria marker
            const markerMatch = description.match(/\[AutoPlaylist:([A-Za-z0-9+/=]+)\]/);
            if (!markerMatch) {
                return null; // Not a playlist created by this system
            }
            
            try {
                const criteriaJson = atob(markerMatch[1]);
                const criteria = JSON.parse(criteriaJson);
                
                // Validate that this has the expected structure
                if (criteria.createdBy === 'SpotifyTagger' && criteria.tempo && criteria.energy && criteria.emotion) {
                    console.log('DEBUG - Successfully parsed playlist criteria:', criteria);
                    return criteria;
                } else {
                    console.log('DEBUG - Invalid criteria structure:', criteria);
                    return null;
                }
            } catch (error) {
                console.error('Error parsing playlist criteria:', error);
                return null;
            }
        }

        // Initialize playlist search functionality
        function setupPlaylistSearch() {
            const playlistSearch = document.getElementById('playlist-search');
            
            if (!playlistSearch) {
                console.log('DEBUG - Playlist search input not found');
                return;
            }
            
            console.log('DEBUG - Setting up playlist search functionality');
            
            playlistSearch.addEventListener('input', function(e) {
                const searchText = e.target.value.toLowerCase();
                
                // Auto-show playlists when user starts typing
                if (searchText.length > 0) {
                    autoShowPlaylistsOnSearch();
                }
                
                const playlistItems = document.querySelectorAll('.playlist-item');
                const totalPlaylists = {{ playlists|length if playlists else 0 }};
                let visibleCount = 0;
                
                playlistItems.forEach(function(item) {
                    const playlistLink = item.querySelector('a');
                    if (playlistLink) {
                        const playlistName = playlistLink.textContent.toLowerCase();
                        
                        if (playlistName.includes(searchText)) {
                            item.style.display = 'block';
                            visibleCount++;
                        } else {
                            item.style.display = 'none';
                        }
                    }
                });
                
                // Update the header count
                const playlistHeader = document.querySelector('#tag-songs-sidebar h4');
                if (playlistHeader && playlistHeader.textContent.includes('Your Playlists')) {
                    if (searchText === '') {
                        playlistHeader.textContent = `Your Playlists (${totalPlaylists})`;
                    } else {
                        playlistHeader.textContent = `Your Playlists (${visibleCount} of ${totalPlaylists})`;
                    }
                }
                
                console.log(`DEBUG - Playlist search: "${searchText}" - showing ${visibleCount} of ${totalPlaylists} playlists`);
            });
        }

        // Refresh the playlists section with fresh data
        function refreshPlaylistsSection() {
            console.log('DEBUG - Refreshing playlists section');
            
            fetch('/get-fresh-playlists')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log(`DEBUG - Received ${data.playlists.length} fresh playlists`);
                        
                        // Update the playlists container
                        const playlistsContainer = document.getElementById('playlists-container');
                        const playlistHeader = document.querySelector('#tag-songs-sidebar h4');
                        
                        if (!playlistsContainer) {
                            console.log('DEBUG - Playlists container not found');
                            return;
                        }
                        
                        // Clear current search if active
                        const playlistSearch = document.getElementById('playlist-search');
                        if (playlistSearch) {
                            playlistSearch.value = '';
                        }
                        
                        // Generate new HTML
                        let playlistsHtml = '';
                        data.playlists.forEach(playlist => {
                            playlistsHtml += `
                                <div class="playlist-item" style="padding: 8px 10px; border-bottom: 1px solid #f0f0f0;">
                                    <a href="/playlist/${playlist.id}" 
                                    style="color: #1db954; text-decoration: none; font-weight: 500; font-size: 14px; display: block; margin-bottom: 2px;">
                                        ${playlist.name}
                                    </a>
                                    <div style="color: #888; font-size: 11px;">
                                        ${playlist.track_count} songs
                                    </div>
                                </div>
                            `;
                        });
                        
                        // Update the DOM
                        playlistsContainer.innerHTML = playlistsHtml;
                        
                        // Update the header count
                        if (playlistHeader && playlistHeader.textContent.includes('Your Playlists')) {
                            playlistHeader.textContent = `Your Playlists (${data.playlists.length})`;
                        }
                        
                        // Reinitialize the search functionality for the new elements
                        setupPlaylistSearch();
                        
                        console.log('DEBUG - Playlists section refreshed successfully');
                        
                    } else {
                        console.error('Error refreshing playlists:', data.error);
                    }
                })
                .catch(error => {
                    console.error('Error fetching fresh playlists:', error);
                });
        }

        // Test function to identify playlists created by this system
        function testPlaylistIdentification() {
            console.log('DEBUG - Testing playlist identification...');
            
            // This will be used later to scan user's playlists
            fetch('/get-user-playlists')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log(`DEBUG - Found ${data.playlists.length} playlists to check`);
                        
                        data.playlists.forEach(playlist => {
                            // We'll need to fetch each playlist's details to get the description
                            console.log(`DEBUG - Checking playlist: ${playlist.name}`);
                            // Note: We'll need a new route to get playlist details including description
                        });
                    }
                })
                .catch(error => {
                    console.error('Error testing playlist identification:', error);
                });
        }

        // Scan for smart playlists created by this system
        function scanSmartPlaylists() {
            console.log('DEBUG - Scanning for smart playlists');
            
            const scanBtn = document.getElementById('scan-playlists-btn');
            const loadingDiv = document.getElementById('smart-playlists-loading');
            const listDiv = document.getElementById('smart-playlists-list');
            
            // Show loading state
            scanBtn.disabled = true;
            scanBtn.textContent = 'Scanning...';
            loadingDiv.style.display = 'block';
            listDiv.innerHTML = '';
            
            fetch('/get-smart-playlists')
                .then(response => response.json())
                .then(data => {
                    console.log('DEBUG - Smart playlists scan result:', data);
                    
                    if (data.success) {
                        displaySmartPlaylists(data.smart_playlists, data.total_playlists_scanned);
                    } else {
                        listDiv.innerHTML = `<div style="text-align: center; padding: 20px; color: #dc3545; font-size: 12px;">Error: ${data.error}</div>`;
                    }
                })
                .catch(error => {
                    console.error('Error scanning smart playlists:', error);
                    listDiv.innerHTML = '<div style="text-align: center; padding: 20px; color: #dc3545; font-size: 12px;">Failed to scan playlists</div>';
                })
                .finally(() => {
                    // Reset button
                    scanBtn.disabled = false;
                    scanBtn.textContent = 'Scan Playlists';
                    loadingDiv.style.display = 'none';
                });
        }

        // Display the found smart playlists
        function displaySmartPlaylists(smartPlaylists, totalScanned) {
            const listDiv = document.getElementById('smart-playlists-list');
            
            console.log(`DEBUG - Displaying ${smartPlaylists.length} smart playlists out of ${totalScanned} total`);
            
            if (smartPlaylists.length === 0) {
                listDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #666; font-size: 12px;">
                        <div style="margin-bottom: 8px;">No smart playlists found</div>
                        <div style="font-size: 11px; color: #888;">Scanned ${totalScanned} playlists</div>
                    </div>
                `;
                return;
            }
            
            let html = `<div style="margin-bottom: 10px; font-size: 11px; color: #666; text-align: center;">Found ${smartPlaylists.length} smart playlists (scanned ${totalScanned} total)</div>`;
            
            smartPlaylists.forEach((playlist, index) => {
                const criteriaText = formatPlaylistCriteria(playlist.criteria);
                const hasError = playlist.parse_error;
                
                html += `
                    <div style="border: 1px solid ${hasError ? '#ffc107' : '#e9ecef'}; border-radius: 8px; padding: 12px; margin-bottom: 10px; ${index % 2 === 0 ? 'background-color: #f8f9fa;' : 'background-color: white;'}">
                        
                        <!-- Playlist name and link -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <a href="${playlist.url}" target="_blank" style="color: #1db954; text-decoration: none; font-weight: 500; font-size: 13px; flex: 1;">
                                ${playlist.name}
                            </a>
                            <div style="font-size: 11px; color: #666; margin-left: 10px;">
                                ${playlist.track_count} songs
                            </div>
                        </div>
                        
                        <!-- Human description -->
                        <div style="font-size: 11px; color: #495057; margin-bottom: 8px; font-style: italic;">
                            "${playlist.human_description}"
                        </div>
                        
                        <!-- Criteria breakdown -->
                        ${hasError ? 
                            `<div style="font-size: 10px; color: #856404; background-color: #fff3cd; padding: 5px; border-radius: 3px;">
                                ⚠️ Could not parse filter criteria
                            </div>` :
                            `<div style="font-size: 10px; color: #666; line-height: 1.3;">
                                ${criteriaText}
                            </div>`
                        }
                        
                        <!-- Refresh button (placeholder for next step) -->
                        <div style="margin-top: 8px; text-align: right;">
                            <button onclick="refreshSmartPlaylist('${playlist.id}', '${playlist.name}')" 
                                    style="background-color: #6c757d; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;" 
                                    ${hasError ? 'disabled title="Cannot refresh - criteria parsing failed"' : ''}>
                                🔄 Refresh
                            </button>
                        </div>
                        
                    </div>
                `;
            });
            
            listDiv.innerHTML = html;
        }

        // Format playlist criteria into human-readable text
        function formatPlaylistCriteria(criteria) {
            if (!criteria) return 'No criteria available';
            
            const parts = [];
            
            // Format tempo range
            if (criteria.t && (criteria.t[0] !== 1 || criteria.t[1] !== 5)) {
                const tempoText = getRangeText(criteria.t[0], criteria.t[1], 'tempo');
                parts.push(`Tempo: ${tempoText}`);
            }
            
            // Format energy range
            if (criteria.e && (criteria.e[0] !== 1 || criteria.e[1] !== 5)) {
                const energyText = getRangeText(criteria.e[0], criteria.e[1], 'energy');
                parts.push(`Energy: ${energyText}`);
            }
            
            // Format emotion range
            if (criteria.m && (criteria.m[0] !== 1 || criteria.m[1] !== 5)) {
                const emotionText = getRangeText(criteria.m[0], criteria.m[1], 'emotion');
                parts.push(`Emotion: ${emotionText}`);
            }
            
            // Format included tags
            if (criteria.i && criteria.i.length > 0) {
                const tagNames = criteria.i.map(tagId => {
                    const tag = window.allTags?.find(t => t.id === tagId);
                    return tag ? tag.name : `ID:${tagId}`;
                });
                parts.push(`Include: ${tagNames.join(', ')}`);
            }
            
            // Format excluded tags
            if (criteria.x && criteria.x.length > 0) {
                const tagNames = criteria.x.map(tagId => {
                    const tag = window.allTags?.find(t => t.id === tagId);
                    return tag ? tag.name : `ID:${tagId}`;
                });
                parts.push(`Exclude: ${tagNames.join(', ')}`);
            }
            
            return parts.length > 0 ? parts.join(' • ') : 'All songs (no filters)';
        }

        // Automatically refresh all smart playlists
        function refreshAllSmartPlaylists() {
            console.log('DEBUG - Starting automatic refresh of all smart playlists');
            
            const refreshBtn = document.getElementById('refresh-all-btn');
            const loadingDiv = document.getElementById('refresh-all-loading');
            const resultsDiv = document.getElementById('refresh-all-results');
            const initialDiv = document.getElementById('refresh-all-initial');
            
            // Show loading state
            refreshBtn.disabled = true;
            refreshBtn.textContent = 'Refreshing...';
            loadingDiv.style.display = 'block';
            resultsDiv.style.display = 'none';
            initialDiv.style.display = 'none';
            
            fetch('/refresh-all-smart-playlists', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                console.log('DEBUG - Refresh all response:', data);
                
                loadingDiv.style.display = 'none';
                
                if (data.success) {
                    displayRefreshResults(data);
                    showRefreshSummaryPopup(data);
                } else {
                    resultsDiv.innerHTML = `<div style="text-align: center; padding: 20px; color: #dc3545; font-size: 12px;">Error: ${data.error}</div>`;
                    resultsDiv.style.display = 'block';
                }
            })
            .catch(error => {
                console.error('Error refreshing all playlists:', error);
                loadingDiv.style.display = 'none';
                resultsDiv.innerHTML = '<div style="text-align: center; padding: 20px; color: #dc3545; font-size: 12px;">Failed to refresh playlists</div>';
                resultsDiv.style.display = 'block';
            })
            .finally(() => {
                // Reset button
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'Refresh All';
            });
        }

        // Display the refresh results in the sidebar
        function displayRefreshResults(data) {
            const resultsDiv = document.getElementById('refresh-all-results');
            
            if (data.playlists_updated === 0) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #666; font-size: 12px;">
                        No smart playlists found<br>
                        <span style="font-size: 10px; color: #888;">Scanned ${data.playlists_scanned} playlists</span>
                    </div>
                `;
            } else {
                let html = '';
                
                // Show updated playlists directly without the blue banner
                data.results.forEach((result, index) => {
                    const hasNewSongs = result.songs_added > 0;
                    
                    html += `
                        <div style="border: 1px solid ${hasNewSongs ? '#1db954' : '#e9ecef'}; border-radius: 8px; padding: 10px; margin-bottom: 8px; ${index % 2 === 0 ? 'background-color: #f8f9fa;' : 'background-color: white;'}">
                            
                            <div style="font-weight: 500; font-size: 12px; color: #333; margin-bottom: 4px;">
                                ${result.playlist_name}
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: #666;">
                                <div>
                                    ${result.original_count} → ${result.new_total} songs
                                </div>
                                <div style="color: ${hasNewSongs ? '#1db954' : '#888'}; font-weight: ${hasNewSongs ? '600' : 'normal'};">
                                    ${hasNewSongs ? `+${result.songs_added} new` : 'up to date'}
                                </div>
                            </div>
                            
                        </div>
                    `;
                });
                
                resultsDiv.innerHTML = html;
            }
            
            resultsDiv.style.display = 'block';
        }

        // Show a comprehensive popup summary
        function showRefreshSummaryPopup(data) {
            let message = '';
            
            if (data.total_songs_added === 0) {
                message = `Smart Playlist Refresh Complete!\n\n`;
                message += `Checked ${data.playlists_updated} smart playlists.\n`;
                message += `All playlists are already up to date!`;
            } else {
                message = `Smart Playlist Refresh Complete!\n\n`;
                message += `Added ${data.total_songs_added} songs across ${data.playlists_updated} playlists:\n\n`;
                
                // Show details for each playlist that got new songs
                data.results.forEach(result => {
                    if (result.songs_added > 0) {
                        message += `"${result.playlist_name}": +${result.songs_added} songs\n`;
                        
                        // Show first few song names
                        const songsToShow = result.new_songs.slice(0, 3);
                        songsToShow.forEach(song => {
                            message += `  • ${song.name} - ${song.artist}\n`;
                        });
                        
                        if (result.new_songs.length > 3) {
                            message += `  ... and ${result.new_songs.length - 3} more\n`;
                        }
                        
                        message += `\n`;
                    }
                });
                
                // Show unchanged playlists count
                const unchangedCount = data.results.filter(r => r.songs_added === 0).length;
                if (unchangedCount > 0) {
                    message += `${unchangedCount} other playlist${unchangedCount === 1 ? '' : 's'} already up to date.`;
                }
            }
            
            alert(message);
        }

        // Toggle playlists display
        function togglePlaylistsDisplay() {
            const container = document.getElementById('playlists-container');
            const button = document.getElementById('toggle-playlists-btn');
            
            if (container.style.display === 'none') {
                // Show playlists
                container.style.display = 'block';
                button.textContent = 'Hide Playlists';
                button.style.backgroundColor = '#6c757d';
                console.log('DEBUG - Playlists displayed');
            } else {
                // Hide playlists
                container.style.display = 'none';
                button.textContent = 'Display Playlists';
                button.style.backgroundColor = '#1db954';
                console.log('DEBUG - Playlists hidden');
            }
        }

        // Auto-show playlists when searching
        function autoShowPlaylistsOnSearch() {
            const container = document.getElementById('playlists-container');
            const button = document.getElementById('toggle-playlists-btn');
            
            if (container && container.style.display === 'none') {
                container.style.display = 'block';
                button.textContent = 'Hide Playlists';
                button.style.backgroundColor = '#6c757d';
                console.log('DEBUG - Auto-showed playlists due to search');
            }
        }

        // Toggle favourite tag for a song
        function toggleFavouriteTag(songId) {
            console.log(`DEBUG - Toggling favourite tag for song ${songId}`);
            
            const button = document.getElementById(`favourite-btn-${songId}`);
            
            // Check if song already has favourite tag
            fetch(`/get-song-tags/${songId}`)
                .then(response => response.json())
                .then(data => {
                    const hasFavourite = data.tags.some(tag => tag.name.toLowerCase() === 'favourite');
                    
                    if (hasFavourite) {
                        // Remove favourite tag
                        const favouriteTag = data.tags.find(tag => tag.name.toLowerCase() === 'favourite');
                        if (favouriteTag) {
                            removeTag(songId, favouriteTag.id);
                            updateFavouriteButtonState(button, false);
                        }
                    } else {
                        // Add favourite tag
                        addTag(songId, null, 'favourite');
                        updateFavouriteButtonState(button, true);
                    }
                })
                .catch(error => {
                    console.error('Error checking favourite tag:', error);
                });
        }

        // Update favourite button visual state
        function updateFavouriteButtonState(button, isFavourite) {
            if (isFavourite) {
                button.style.backgroundColor = '#ffc107';
                button.style.color = '#333';
                button.style.borderColor = '#f0ad4e';
            } else {
                button.style.backgroundColor = '#ffffff';
                button.style.color = '#333';
                button.style.borderColor = '#ddd';
            }
            // Text never changes - always stays "⭐ Favourite"
        }

        // Initialize favourite button state for current song
        function initializeFavouriteButton(songId) {
            const button = document.getElementById(`favourite-btn-${songId}`);
            if (!button) return;
            
            fetch(`/get-song-tags/${songId}`)
                .then(response => response.json())
                .then(data => {
                    const hasFavourite = data.tags.some(tag => tag.name.toLowerCase() === 'favourite');
                    updateFavouriteButtonState(button, hasFavourite);
                })
                .catch(error => {
                    console.error('Error initializing favourite button:', error);
                });
        }

        function navigateToNextSong() {
            const untaggedToggle = document.getElementById('untagged-toggle');
            const untaggedOnly = untaggedToggle ? untaggedToggle.checked : false;
            
            console.log(`DEBUG - navigateToNextSong: untaggedOnly=${untaggedOnly}, currentOffset=${currentSongOffset}`);
            
            if (!untaggedOnly) {
                // Simple case
                const nextOffset = currentSongOffset + 1;
                console.log(`DEBUG - Next song: current offset ${currentSongOffset} -> ${nextOffset}`);
                loadSongAjax(nextOffset, untaggedOnly);
            } else {
                // Find next untagged song
                console.log('DEBUG - Finding next untagged song via backend');
                showLoadingState();
                
                const url = `/get-next-untagged-offset?offset=${currentSongOffset}`;
                console.log(`DEBUG - Fetching: ${url}`);
                
                fetch(url)
                    .then(response => {
                        console.log(`DEBUG - Response status: ${response.status}`);
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log(`DEBUG - Response data:`, data);
                        
                        if (data.found) {
                            console.log(`DEBUG - Found next untagged song at offset ${data.offset}`);
                            loadSongAjax(data.offset, untaggedOnly);
                        } else {
                            console.log(`DEBUG - No next untagged song: ${data.reason}`);
                            hideLoadingState();
                            alert(`No more untagged songs found: ${data.reason}`);
                        }
                    })
                    .catch(error => {
                        console.error('DEBUG - Error finding next untagged song:', error);
                        hideLoadingState();
                        alert(`Error: ${error.message}`);
                    });
            }
        }

        function navigateToPrevSong() {
            const untaggedToggle = document.getElementById('untagged-toggle');
            const untaggedOnly = untaggedToggle ? untaggedToggle.checked : false;
            
            if (!untaggedOnly) {
                // Simple case
                if (currentSongOffset <= 0) {
                    console.log('DEBUG - Already at beginning');
                    return;
                }
                
                const prevOffset = currentSongOffset - 1;
                console.log(`DEBUG - Previous song: current offset ${currentSongOffset} -> ${prevOffset}`);
                loadSongAjax(prevOffset, untaggedOnly);
            } else {
                // Find previous untagged song
                console.log('DEBUG - Finding previous untagged song');
                showLoadingState();
                
                fetch(`/get-prev-untagged-offset?offset=${currentSongOffset}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.found) {
                            console.log(`DEBUG - Found previous untagged song at offset ${data.offset}`);
                            loadSongAjax(data.offset, untaggedOnly);
                        } else {
                            console.log(`DEBUG - No previous untagged song: ${data.reason}`);
                            hideLoadingState();
                            if (data.reason === 'at_beginning') {
                                alert('Already at the beginning');
                            } else {
                                alert('No previous untagged songs found');
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error finding previous untagged song:', error);
                        hideLoadingState();
                    });
            }
        }

        function loadSongAjax(targetOffset, untaggedOnly) {
            console.log(`DEBUG - AJAX loading song at offset ${targetOffset}, untagged_only: ${untaggedOnly}`);
            
            // Show loading state
            showLoadingState();
            
            const params = new URLSearchParams({
                untagged_only: untaggedOnly
            });
            
            fetch(`/get-song-data/${targetOffset}?${params}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log(`DEBUG - AJAX loaded: ${data.song.name} at position ${data.song.actual_position}`);
                        updateSongDisplay(data.song, data.song.actual_position, untaggedOnly);
                        
                        // Update browser URL without page reload
                        const newUrl = `/tag-liked-songs?offset=${data.song.actual_position}&untagged_only=${untaggedOnly}`;
                        window.history.pushState({}, '', newUrl);
                        
                        // Start preloading next song
                        setTimeout(() => preloadNextSong(), 500);
                        
                    } else {
                        console.error('Error loading song:', data.error);
                        alert('No more songs found');
                    }
                })
                .catch(error => {
                    console.error('AJAX navigation error:', error);
                    hideLoadingState();
                });
        }

        function showLoadingState() {
            // Remove any existing loading overlay first
            const existingOverlay = document.getElementById('loading-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            const iframe = document.getElementById('spotify-iframe');
            const container = iframe.parentElement;
            
            // Add loading overlay
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'loading-overlay';
            loadingDiv.style.cssText = `
                position: absolute; 
                top: 0; left: 0; right: 0; bottom: 0; 
                background: rgba(255,255,255,0.8); 
                display: flex; align-items: center; justify-content: center;
                border-radius: 12px; z-index: 10;
                font-size: 14px; color: #666;
            `;
            loadingDiv.textContent = 'Loading next song...';
            
            container.style.position = 'relative';
            container.appendChild(loadingDiv);
        }

        function hideLoadingState() {
            const loadingDiv = document.getElementById('loading-overlay');
            if (loadingDiv) {
                loadingDiv.remove();
            }
        }

        function updateSongDisplay(songData, newOffset, untaggedOnly) {
            console.log(`DEBUG - Updating display for: ${songData.name} at offset ${newOffset}`);
            
            // Update global tracking variables
            currentSongOffset = newOffset;
            currentSongId = songData.db_id;
            currentUntaggedOnly = untaggedOnly;
            
            console.log(`DEBUG - Updated global state: offset=${currentSongOffset}, songId=${currentSongId}, untagged=${currentUntaggedOnly}`);
            
            // Update Spotify iframe
            const iframe = document.getElementById('spotify-iframe');
            iframe.src = `https://open.spotify.com/embed/track/${songData.spotify_id}?utm_source=generator&theme=0`;
            
            // Update progress indicator
            const progressElement = document.getElementById('song-progress');
            if (progressElement) {
                let progressText;
                if (untaggedOnly) {
                    progressText = `Song ${newOffset + 1}/${totalUntaggedSongs} (untagged only)`;
                } else {
                    progressText = `Song ${newOffset + 1}/${totalLikedSongs}`;
                }
                progressElement.textContent = progressText;
            }
            
            // IMPORTANT: Update DOM elements FIRST before loading data
            updateTagContainersForNewSong(songData.db_id);
            
            // Small delay to ensure DOM updates complete before API calls
            setTimeout(() => {
                console.log(`DEBUG - Loading attributes and features for song ${songData.db_id}`);
                
                // Now load song data - elements should exist with correct IDs
                loadSongAttributes(songData.db_id);
                loadAudioFeatures(songData.db_id);
                initializeFavouriteButton(songData.db_id);
                
                // Refresh tags for new song
                refreshTagsForSong(songData.db_id);
                
            }, 100); // 100ms delay to ensure DOM updates complete
            
            hideLoadingState();
        }

        function updateTagContainersForNewSong(newSongId) {
            console.log(`DEBUG - Updating DOM elements for song ID ${newSongId}`);
            
            // Update all tag-related elements with new song ID
            const tagSearch = document.querySelector('.tag-search');
            const createBtn = document.querySelector('.create-tag-btn');
            const activeTagsSection = document.querySelector('[id^="active-tags-"]');
            const availableTagsContainer = document.querySelector('.available-tags-container');
            
            if (tagSearch) {
                tagSearch.setAttribute('data-song-id', newSongId);
            }
            
            if (createBtn) {
                createBtn.setAttribute('data-song-id', newSongId);
            }
            
            if (activeTagsSection) {
                activeTagsSection.id = `active-tags-${newSongId}`;
            }
            
            if (availableTagsContainer) {
                availableTagsContainer.setAttribute('data-song-id', newSongId);
                // Clear current tags data to force refresh
                availableTagsContainer.setAttribute('data-current-tags', '');
            }
            
            // Update all slider and triangle IDs - DON'T reset values yet
            ['tempo', 'energy', 'emotion'].forEach(attr => {
                const slider = document.querySelector(`[id^="${attr}-slider-"]`);
                const label = document.querySelector(`[id^="${attr}-label-"]`);
                const triangle = document.querySelector(`[id^="${attr}-triangle-"]`);
                
                if (slider) {
                    const oldId = slider.id;
                    slider.id = `${attr}-slider-${newSongId}`;
                    // DON'T reset slider value here - let loadSongAttributes handle it
                    slider.setAttribute('onchange', `updateAttribute(${newSongId}, '${attr === 'emotion' ? 'mood' : attr}', this.value)`);
                    console.log(`DEBUG - Updated slider: ${oldId} -> ${slider.id}`);
                }
                
                if (label) {
                    label.id = `${attr}-label-${newSongId}`;
                    // DON'T reset label - let loadSongAttributes set the correct text
                }
                
                if (triangle) {
                    const oldId = triangle.id;
                    triangle.id = `${attr}-triangle-${newSongId}`;
                    // Reset triangle visibility but let loadAudioFeatures position it correctly
                    triangle.classList.remove('pos-1', 'pos-2', 'pos-3', 'pos-4', 'pos-5', 'visible');
                    console.log(`DEBUG - Updated triangle: ${oldId} -> ${triangle.id}`);
                }
            });
            
            // Update favourite button
            const favBtn = document.querySelector('[id^="favourite-btn-"]');
            if (favBtn) {
                favBtn.id = `favourite-btn-${newSongId}`;
                favBtn.setAttribute('onclick', `toggleFavouriteTag(${newSongId})`);
                // Reset button to default state - will be updated by initializeFavouriteButton
                favBtn.style.backgroundColor = '#ffffff';
                favBtn.style.color = '#333';
                favBtn.style.borderColor = '#ddd';
            }
            
            // Update audio features display (hidden elements)
            const audioFeaturesDiv = document.querySelector('[id^="audio-features-"]');
            if (audioFeaturesDiv) {
                audioFeaturesDiv.id = `audio-features-${newSongId}`;
                
                // Update display elements
                const tempoDisplay = audioFeaturesDiv.querySelector('[id^="display-tempo-"]');
                const energyDisplay = audioFeaturesDiv.querySelector('[id^="display-energy-"]');
                
                if (tempoDisplay) {
                    tempoDisplay.id = `display-tempo-${newSongId}`;
                    tempoDisplay.textContent = 'Loading...';
                }
                if (energyDisplay) {
                    energyDisplay.id = `display-energy-${newSongId}`;
                    energyDisplay.textContent = 'Loading...';
                }
            }
            
            console.log(`DEBUG - DOM update complete for song ${newSongId}`);
        }

        </script>
        
    {% else %}
        <!-- User is not logged in -->
        <div style="background-color: #f8d7da; color: #721c24; padding: 15px; border-radius: 10px; margin: 20px 0;">
            <h3>Not Connected to Spotify</h3>
            <p>You need to log in to Spotify to create playlists and view your data.</p>
        </div>
        
        <a href="/login" style="background-color: #1db954; color: white;">Login with Spotify</a>
    {% endif %}

    <!-- Tag Management Modal -->
    <div id="tag-manager-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 10px; padding: 20px; max-width: 900px; width: 95%; max-height: 85%; overflow-y: auto;">
            
            <!-- Header -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px;">
                <h3 style="margin: 0; color: #333;">Manage Tags</h3>
                <button onclick="closeTagManager()" style="background: none; border: none; font-size: 24px; color: #666; cursor: pointer; padding: 0; width: 30px; height: 30px;">×</button>
            </div>
            
            
            <!-- Four-section grid layout -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                
                <!-- Context/Vibe Section (moved to first position) -->
                <div style="border: 2px solid #dee2e6; border-radius: 8px; background-color: #fafafa;">
                    <h4 style="margin: 0 0 10px 0; color: #495057; text-align: center; padding: 10px; background-color: #f8f9fa; border-radius: 6px 6px 0 0; font-size: 14px;">Context/Vibe</h4>
                    <div id="context-list" style="min-height: 120px; padding: 10px;">
                        <div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No context/vibe tags yet</div>
                    </div>
                </div>
                
                <!-- Instrumentation Section (moved to second position) -->
                <div style="border: 2px solid #dee2e6; border-radius: 8px; background-color: #fafafa;">
                    <h4 style="margin: 0 0 10px 0; color: #495057; text-align: center; padding: 10px; background-color: #f8f9fa; border-radius: 6px 6px 0 0; font-size: 14px;">Instrumentation</h4>
                    <div id="instrumentation-list" style="min-height: 120px; padding: 10px;">
                        <div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No instrumentation tags yet</div>
                    </div>
                </div>
                
                <!-- Genre Sub Tag Section -->
                <div style="border: 2px solid #dee2e6; border-radius: 8px; background-color: #fafafa;">
                    <h4 style="margin: 0 0 10px 0; color: #495057; text-align: center; padding: 10px; background-color: #f8f9fa; border-radius: 6px 6px 0 0; font-size: 14px;">Genre Sub Tag</h4>
                    <div id="genre-sub-list" style="min-height: 120px; padding: 10px;">
                        <div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No genre sub tags yet</div>
                    </div>
                </div>
                
                <!-- Genre Section -->
                <div style="border: 2px solid #dee2e6; border-radius: 8px; background-color: #fafafa;">
                    <h4 style="margin: 0 0 10px 0; color: #495057; text-align: center; padding: 10px; background-color: #f8f9fa; border-radius: 6px 6px 0 0; font-size: 14px;">Genre</h4>
                    <div id="genre-list" style="min-height: 120px; padding: 10px;">
                        <div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">No genre tags yet</div>
                    </div>
                </div>
                
            </div>
            
            <!-- Footer -->
            <div style="margin-top: 20px; text-align: center; border-top: 1px solid #e9ecef; padding-top: 15px;">
                <button onclick="closeTagManager()" style="background-color: #1db954; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px;">
                    Done
                </button>
            </div>
            
        </div>
    </div>

    <!-- Playlist Selection Modal for Import -->
    <div id="playlist-import-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 10px; padding: 20px; max-width: 600px; width: 90%; max-height: 80%; overflow-y: auto;">
            
            <!-- Header -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px;">
                <h3 style="margin: 0; color: #333;">Select Playlists to Import</h3>
                <button onclick="closePlaylistImportModal()" style="background: none; border: none; font-size: 24px; color: #666; cursor: pointer; padding: 0; width: 30px; height: 30px;">×</button>
            </div>
            
            <!-- Instructions -->
            <div style="background-color: #e7f3ff; padding: 12px; border-radius: 5px; margin-bottom: 20px; font-size: 12px; color: #0c5460;">
                <strong>Select which playlists to import songs from:</strong><br>
                Only songs not already in your Liked Songs will be added. All playlists are selected by default.
            </div>
            
            <!-- Select All Controls -->
            <div style="margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 5px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="select-all-playlists" checked style="margin-right: 8px; cursor: pointer;">
                    <span style="font-weight: 600;">Select All Playlists</span>
                </label>
            </div>
            
            <!-- Playlists List -->
            <div id="playlists-for-import" style="max-height: 300px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 5px; padding: 10px;">
                <div style="text-align: center; color: #666; padding: 20px;">Loading your playlists...</div>
            </div>
            
            <!-- Footer -->
            <div style="margin-top: 20px; display: flex; justify-content: space-between; align-items: center; border-top: 1px solid #e9ecef; padding-top: 15px;">
                <div id="selected-playlists-count" style="font-size: 12px; color: #666;">
                    0 playlists selected
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="closePlaylistImportModal()" style="background-color: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px;">
                        Cancel
                    </button>
                    <button id="confirm-import-btn" onclick="confirmImportSelectedPlaylists()" style="background-color: #1db954; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px;">
                        Import Selected
                    </button>
                </div>
            </div>
            
        </div>
    </div>

{% endblock %}